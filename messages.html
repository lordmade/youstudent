<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Nexus â€“ Messages</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

    :root {
      --primary: #6366F1;
      --primary-soft: #EEF2FF;
      --primary-light: #818CF8;
      --primary-dark: #4F46E5;
      --bg: #F8FAFC;
      --surface: #FFFFFF;
      --text: #0F172A;
      --text-secondary: #64748B;
      --text-muted: #94A3B8;
      --border: #E2E8F0;
      --online: #10B981;
      --encrypted: #10B981;
      --error: #EF4444;
      --success: #10B981;
      --pending: #F59E0B;
      --shimmer-base: #E2E8F0;
      --shimmer-highlight: #F1F5F9;
      --chat-sent: #6366F1;
      --chat-received: #F1F5F9;
      --glass-bg: rgba(255, 255, 255, 0.85);
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }

    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 100%);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      margin: 0;
      min-height: 100vh;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior: none;
      -webkit-font-smoothing: antialiased;
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr;
      max-width: 720px;
      margin: 0 auto;
      padding-bottom: 100px;
    }

    @media (min-width: 768px) {
      .layout {
        grid-template-columns: 280px 1fr;
        max-width: 1100px;
        padding-bottom: 0;
        gap: 2rem;
        padding: 0 1rem;
      }
    }

    .sidebar {
      display: none;
      position: sticky;
      top: 0;
      height: 100vh;
      padding: 1.5rem 1rem;
      border-right: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(20px);
    }

    @media (min-width: 768px) {
      .sidebar { display: flex; flex-direction: column; }
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.875rem 1.25rem;
      border-radius: 12px;
      font-size: 1.05rem;
      font-weight: 600;
      color: var(--text-secondary);
      transition: all 0.2s;
      cursor: pointer;
      margin-bottom: 0.25rem;
    }

    .nav-item:hover, .nav-item.active {
      background: rgba(99, 102, 241, 0.08);
      color: var(--primary);
    }

    .main-content {
      background: var(--surface);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      border-radius: 24px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
      overflow: hidden;
      margin-top: 1rem;
    }

    @media (max-width: 768px) {
      .main-content { border-radius: 0; border: none; margin: 0; }
    }

    .chat-header {
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      padding: 1.25rem;
      z-index: 10;
    }

    .header-title {
      font-size: 1.5rem;
      font-weight: 800;
      margin-bottom: 0.5rem;
    }

    .search-box {
      position: relative;
      margin-top: 0.75rem;
    }

    .search-input {
      width: 100%;
      padding: 0.75rem 1rem 0.75rem 2.75rem;
      border: 2px solid var(--border);
      border-radius: 12px;
      font-size: 1rem;
      outline: none;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
    }

    .search-input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
    }

    .search-icon {
      position: absolute;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
    }

    .chat-list {
      flex: 1;
      overflow-y: auto;
    }

    /* Modern Friend Card with Last Message */
    .friend-card {
      display: flex;
      align-items: center;
      gap: 0.875rem;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 1px solid var(--border);
      position: relative;
    }

    .friend-card:hover {
      background: var(--bg);
    }

    .friend-card:active {
      background: rgba(99, 102, 241, 0.05);
    }

    .avatar-container {
      position: relative;
      flex-shrink: 0;
    }

    .friend-avatar {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid white;
      box-shadow: var(--shadow-sm);
    }

    .online-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 14px;
      height: 14px;
      background: var(--online);
      border: 3px solid white;
      border-radius: 50%;
      display: none;
    }

    .online-indicator.show { display: block; }

    .friend-content {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .friend-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .friend-name {
      font-weight: 700;
      font-size: 1rem;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .timestamp {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-weight: 600;
      flex-shrink: 0;
    }

    .timestamp.unread {
      color: var(--primary);
      font-weight: 700;
    }

    .message-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .last-message {
      font-size: 0.875rem;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .last-message.unread {
      color: var(--text);
      font-weight: 600;
    }

    .unread-badge {
      background: var(--primary);
      color: white;
      font-size: 0.75rem;
      font-weight: 700;
      min-width: 20px;
      height: 20px;
      border-radius: 9999px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
      flex-shrink: 0;
    }

    .relationship-badge {
      font-size: 0.65rem;
      padding: 0.125rem 0.375rem;
      border-radius: 4px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .badge-mutual {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
    }

    .badge-following { background: var(--primary-soft); color: var(--primary); }
    .badge-follower { background: #DCFCE7; color: #16A34A; }

    .bottom-nav {
      position: fixed;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 9999px;
      z-index: 50;
      padding: 0.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(255,255,255,0.5);
    }

    @media (min-width: 768px) { .bottom-nav { display: none; } }

    .nav-bottom-item {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      color: var(--text-secondary);
      border-radius: 50%;
      transition: all 0.2s;
    }

    .nav-bottom-item.active {
      color: var(--primary);
      background: rgba(99, 102, 241, 0.12);
    }

    #fullChatView {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100dvh;
      background: var(--bg);
      display: none;
      flex-direction: column;
      z-index: 2000;
    }

    #fullChatView.active { display: flex; }

    .chat-view-header {
      height: 70px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 1.25rem;
    }

    .back-btn {
      padding: 0.5rem;
      margin-right: 0.75rem;
      cursor: pointer;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #messageList {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .message {
      max-width: 75%;
      padding: 0.75rem 1rem;
      border-radius: 1.5rem;
      font-size: 0.95rem;
      word-wrap: break-word;
    }

    .message.sent {
      align-self: flex-end;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
      border-bottom-right-radius: 0.5rem;
    }

    .message.received {
      align-self: flex-start;
      background: var(--chat-received);
      color: var(--text);
      border-bottom-left-radius: 0.5rem;
    }

    .chat-input-area {
      background: rgba(255,255,255,0.95);
      padding: 1rem;
      display: flex;
      gap: 0.5rem;
      border-top: 1px solid var(--border);
    }

    .input-wrapper {
      flex: 1;
      background: var(--bg);
      border-radius: 1.5rem;
      padding: 0.75rem 1rem;
      border: 2px solid var(--border);
    }

    #messageInput {
      width: 100%;
      background: transparent;
      border: none;
      font-size: 1rem;
      resize: none;
      color: var(--text);
      font-family: inherit;
    }

    #messageInput:focus { outline: none; }

    #sendBtn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: none;
      opacity: 0.5;
    }

    #sendBtn.active { opacity: 1; }

    #toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 9999px;
      z-index: 3000;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
    }

    #toast.show { opacity: 1; }

    .shimmer {
      background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
  </style>
</head>
<body>

  <div id="toast"></div>

  <div class="layout">
    <aside class="sidebar">
      <div class="logo-box" style="display:flex;align-items:center;gap:0.75rem;margin-bottom:2rem;">
        <svg width="36" height="36" viewBox="0 0 40 40" fill="none">
          <rect width="40" height="40" rx="12" fill="#6366F1"/>
          <path d="M12 20L18 26L28 14" stroke="white" stroke-width="4"/>
        </svg>
        <span style="font-weight:800;font-size:1.25rem;">Nexus</span>
      </div>
      <nav>
        <div class="nav-item" onclick="window.location.href='index.html'">
          <i data-feather="home"></i><span>Home</span>
        </div>
        <div class="nav-item" onclick="window.location.href='explore.html'">
          <i data-feather="compass"></i><span>Explore</span>
        </div>
        <div class="nav-item" onclick="window.location.href='profile.html'">
          <i data-feather="user"></i><span>Profile</span>
        </div>
      </nav>
    </aside>

    <main class="main-content">
      <div class="chat-header">
        <h1 class="header-title">Messages</h1>
        <div class="search-box">
          <i data-feather="search" class="search-icon" style="width:20px;height:20px;"></i>
          <input type="text" class="search-input" placeholder="Search conversations..." id="search-input" oninput="searchFriends()">
        </div>
      </div>

      <div class="chat-list" id="friend-list">
        <!-- Skeleton loading -->
        <div class="friend-card" style="pointer-events:none;">
          <div class="shimmer" style="width:56px;height:56px;border-radius:50%;"></div>
          <div style="flex:1;">
            <div style="display:flex;justify-content:space-between;margin-bottom:0.5rem;">
              <div class="shimmer" style="width:120px;height:16px;"></div>
              <div class="shimmer" style="width:40px;height:14px;"></div>
            </div>
            <div class="shimmer" style="width:200px;height:14px;"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <nav class="bottom-nav">
    <a href="index.html" class="nav-bottom-item"><i data-feather="home" style="width:22px;height:22px;"></i></a>
    <a href="explore.html" class="nav-bottom-item"><i data-feather="compass" style="width:22px;height:22px;"></i></a>
    <a href="messages.html" class="nav-bottom-item active"><i data-feather="message-circle" style="width:22px;height:22px;"></i></a>
    <a href="profile.html" class="nav-bottom-item"><i data-feather="user" style="width:22px;height:22px;"></i></a>
  </nav>

  <div id="fullChatView">
    <div class="chat-view-header">
      <div class="back-btn" onclick="closeFullChat()">
        <i data-feather="arrow-left" style="width:24px;height:24px;"></i>
      </div>
      <img id="chatFriendAvatar" src="" style="width:40px;height:40px;border-radius:50%;margin-right:0.75rem;">
      <div>
        <div id="chatFriendName" style="font-weight:700;"></div>
        <div id="chatStatus" style="font-size:0.8rem;color:var(--text-secondary);"></div>
      </div>
    </div>

    <div id="messageList"></div>

    <div class="chat-input-area">
      <div class="input-wrapper">
        <textarea id="messageInput" rows="1" placeholder="Type a message..." oninput="autoResize(this)" onkeypress="handleEnter(event)"></textarea>
      </div>
      <button id="sendBtn" onclick="sendMessage()">
        <i data-feather="arrow-up" style="width:20px;height:20px;"></i>
      </button>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.appspot.com",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    let currentUser = null;
    let usersList = [];
    let sharedKeys = JSON.parse(localStorage.getItem('sharedKeys') || '{}');
    let currentFriendUid = null;
    let currentRoomId = null;

    // Crypto functions (same as before)
    async function generateKeyPair() {
      try {
        const keyPair = await crypto.subtle.generateKey(
          { name: "ECDH", namedCurve: "P-256" },
          true,
          ["deriveBits"]
        );
        const pub = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
        const priv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        localStorage.setItem('privateKey', JSON.stringify(priv));
        return pub;
      } catch (err) { return null; }
    }

    async function deriveSharedSecret(friendPublicJwk) {
      try {
        const privateKeyJwk = JSON.parse(localStorage.getItem('privateKey'));
        if (!privateKeyJwk) return null;
        
        const privateKey = await crypto.subtle.importKey(
          "jwk", privateKeyJwk, 
          { name: "ECDH", namedCurve: "P-256" }, 
          false, ["deriveBits"]
        );
        
        const friendPublicKey = await crypto.subtle.importKey(
          "jwk", friendPublicJwk, 
          { name: "ECDH", namedCurve: "P-256" }, 
          false, []
        );
        
        const sharedSecret = await crypto.subtle.deriveBits(
          { name: "ECDH", public: friendPublicKey },
          privateKey, 256
        );
        
        return Array.from(new Uint8Array(sharedSecret))
          .map(b => b.toString(16).padStart(2, '0')).join('');
      } catch (err) { return null; }
    }

    function encrypt(text, key) {
      if (!key) return null;
      try { return CryptoJS.AES.encrypt(text, key).toString(); } 
      catch (e) { return null; }
    }

    function decrypt(ciphertext, key) {
      if (!ciphertext || !key) return null;
      try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, key);
        return bytes.toString(CryptoJS.enc.Utf8) || null;
      } catch (e) { return null; }
    }

    async function ensureKeysForUser(userId, userData) {
      if (sharedKeys[userId]) return sharedKeys[userId];
      if (userData?.publicKey) {
        const secret = await deriveSharedSecret(typeof userData.publicKey === 'string' ? 
          JSON.parse(userData.publicKey) : userData.publicKey);
        if (secret) {
          sharedKeys[userId] = secret;
          localStorage.setItem('sharedKeys', JSON.stringify(sharedKeys));
          return secret;
        }
      }
      return null;
    }

    function showToast(msg, type = 'success') {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.className = `show ${type}`;
      setTimeout(() => t.className = '', 3000);
    }

    function timeAgo(timestamp) {
      if (!timestamp) return '';
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}d`;
      return new Date(timestamp).toLocaleDateString();
    }

    function generateLetterAvatar(name) {
      if (!name) name = 'U';
      const initials = name.trim().split(/\s+/).map(w => w[0]).slice(0,2).join('').toUpperCase();
      const colors = ['#6366f1','#10b981','#f59e0b','#ef4444','#8b5cf6','#ec4899'];
      const hash = name.split('').reduce((a,b) => a + b.charCodeAt(0), 0);
      const bg = colors[hash % colors.length];
      
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 100;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,100,100);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 40px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(initials, 50, 50);
      return canvas.toDataURL();
    }

    // ==================== LOAD FRIENDS WITH CHAT DATA ====================

    async function loadAllFriends() {
      if (!currentUser) return;

      try {
        // Get following and followers
        const [followingSnap, followersSnap] = await Promise.all([
          db.ref(`following/${currentUser.uid}`).once('value'),
          db.ref(`followers/${currentUser.uid}`).once('value')
        ]);

        const followingIds = followingSnap.exists() ? Object.keys(followingSnap.val()) : [];
        const followerIds = followersSnap.exists() ? Object.keys(followersSnap.val()) : [];
        const uniqueUserIds = [...new Set([...followingIds, ...followerIds])];

        if (uniqueUserIds.length === 0) {
          document.getElementById('friend-list').innerHTML = '<div style="text-align:center;padding:3rem;color:var(--text-secondary);">No friends yet</div>';
          return;
        }

        // Fetch user data AND chat metadata for each
        const userPromises = uniqueUserIds.map(async (userId) => {
          try {
            // Get profile
            let userSnap = await db.ref(`users/${userId}/profile`).once('value');
            if (!userSnap.exists()) userSnap = await db.ref(`users/${userId}`).once('value');
            const userData = userSnap.val() || {};
            
            // Get chat metadata (last message, timestamp, unread count)
            const chatSnap = await db.ref(`users/${currentUser.uid}/chats/${userId}`).once('value');
            const chatData = chatSnap.val() || {};
            
            // Determine relationship
            const isFollowing = followingIds.includes(userId);
            const isFollower = followerIds.includes(userId);
            let relationship = 'follower';
            if (isFollowing && isFollower) relationship = 'mutual';
            else if (isFollowing) relationship = 'following';
            
            // Decrypt last message if possible
            let lastMessagePreview = 'Start a conversation';
            let hasKey = false;
            
            if (chatData.lastMsg) {
              // Try to get key
              if (!sharedKeys[userId] && userData.publicKey) {
                await ensureKeysForUser(userId, userData);
              }
              
              const key = sharedKeys[userId];
              if (key) {
                const decrypted = decrypt(chatData.lastMsg, key);
                if (decrypted) {
                  lastMessagePreview = decrypted;
                  hasKey = true;
                } else {
                  lastMessagePreview = 'ðŸ”’ Encrypted message';
                  hasKey = true; // Has key but maybe failed to decrypt (old format)
                }
              } else {
                lastMessagePreview = 'ðŸ”’ Encrypted';
              }
            }
            
            return {
              uid: userId,
              name: userData.name || userData.displayName || 'User',
              photo: userData.photo || userData.photoURL || null,
              publicKey: userData.publicKey,
              relationship,
              lastMessage: lastMessagePreview,
              lastMsgTs: chatData.ts || 0,
              unreadCount: chatData.unreadCount || 0,
              hasKey,
              online: false // Will be updated by listener
            };
          } catch (err) { return null; }
        });

        let users = (await Promise.all(userPromises)).filter(u => u !== null);
        
        // Sort by most recent message first (timestamp descending)
        users.sort((a, b) => b.lastMsgTs - a.lastMsgTs);
        
        // Separate users with chats (top) from new friends (bottom)
        const withChats = users.filter(u => u.lastMsgTs > 0);
        const newFriends = users.filter(u => u.lastMsgTs === 0);
        users = [...withChats, ...newFriends];
        
        usersList = users;
        renderFriendList(users);
        
        // Set up online listeners
        users.forEach(user => {
          db.ref(`users/${user.uid}/online`).on('value', (s) => {
            user.online = s.val() === true;
            const indicator = document.getElementById(`online_${user.uid}`);
            if (indicator) {
              if (user.online) indicator.classList.add('show');
              else indicator.classList.remove('show');
            }
          });
        });

      } catch (err) {
        console.error('Error:', err);
        showToast('Error loading messages', 'error');
      }
    }

    function renderFriendList(users) {
      const list = document.getElementById('friend-list');
      list.innerHTML = '';
      
      users.forEach(user => {
        const card = document.createElement('div');
        card.className = 'friend-card';
        card.onclick = () => openFullChat(user);
        
        const timeStr = user.lastMsgTs ? timeAgo(user.lastMsgTs) : '';
        const unreadClass = user.unreadCount > 0 ? 'unread' : '';
        
        let badgeHTML = '';
        if (user.relationship === 'mutual') badgeHTML = '<span class="relationship-badge badge-mutual">M</span>';
        else if (user.relationship === 'following') badgeHTML = '<span class="relationship-badge badge-following">F</span>';
        
        card.innerHTML = `
          <div class="avatar-container">
            <img src="${user.photo || generateLetterAvatar(user.name)}" class="friend-avatar" 
                 onerror="this.src='${generateLetterAvatar(user.name)}'">
            <div class="online-indicator ${user.online ? 'show' : ''}" id="online_${user.uid}"></div>
          </div>
          <div class="friend-content">
            <div class="friend-header-row">
              <div class="friend-name">
                ${user.name} ${badgeHTML}
              </div>
              ${timeStr ? `<div class="timestamp ${unreadClass}">${timeStr}</div>` : ''}
            </div>
            <div class="message-row">
              <div class="last-message ${unreadClass}">
                ${user.lastMessage === 'Start a conversation' ? 
                  '<span style="color:var(--text-muted);font-style:italic;">' + user.lastMessage + '</span>' : 
                  user.lastMessage}
              </div>
              ${user.unreadCount > 0 ? `<div class="unread-badge">${user.unreadCount}</div>` : ''}
            </div>
          </div>
        `;
        
        list.appendChild(card);
      });
      
      feather.replace();
    }

    // ==================== CHAT ====================

    async function openFullChat(user) {
      currentFriendUid = user.uid;
      currentRoomId = currentUser.uid < user.uid ? 
        currentUser.uid + "_" + user.uid : user.uid + "_" + currentUser.uid;
      
      document.getElementById('chatFriendName').textContent = user.name;
      document.getElementById('chatFriendAvatar').src = user.photo || generateLetterAvatar(user.name);
      document.getElementById('chatStatus').textContent = user.online ? 'Online' : 'Offline';
      
      if (!sharedKeys[user.uid] && user.publicKey) {
        await ensureKeysForUser(user.uid, user);
      }
      
      document.getElementById('fullChatView').classList.add('active');
      document.body.style.overflow = 'hidden';
      history.pushState({chatOpen: true}, '');
      
      loadMessages();
      markAsRead(user.uid);
    }

    function closeFullChat() {
      document.getElementById('fullChatView').classList.remove('active');
      document.body.style.overflow = '';
      if (history.state?.chatOpen) history.back();
    }

    window.addEventListener('popstate', (e) => {
      if (document.getElementById('fullChatView').classList.contains('active')) {
        closeFullChat();
      }
    });

    function loadMessages() {
      const list = document.getElementById('messageList');
      list.innerHTML = '';
      
      db.ref(`messages/${currentRoomId}`).limitToLast(50).on('child_added', (snap) => {
        const msg = snap.val();
        if (!msg) return;
        
        const isSent = msg.sender === currentUser.uid;
        const key = sharedKeys[currentFriendUid];
        let text = msg.text;
        
        if (key && !isSent) {
          const decrypted = decrypt(msg.text, key);
          if (decrypted) text = decrypted;
        }
        
        const el = document.createElement('div');
        el.className = `message ${isSent ? 'sent' : 'received'}`;
        el.innerHTML = `<div>${escapeHtml(text)}</div>`;
        list.appendChild(el);
        list.scrollTop = list.scrollHeight;
      });
    }

    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text || !currentFriendUid) return;
      
      const key = sharedKeys[currentFriendUid];
      if (!key) {
        showToast('No encryption key', 'error');
        return;
      }
      
      const encrypted = encrypt(text, key);
      if (!encrypted) return;
      
      const timestamp = Date.now();
      
      // Optimistic UI
      const list = document.getElementById('messageList');
      const el = document.createElement('div');
      el.className = 'message sent';
      el.innerHTML = `<div>${escapeHtml(text)}</div>`;
      list.appendChild(el);
      list.scrollTop = list.scrollHeight;
      
      input.value = '';
      input.style.height = 'auto';
      document.getElementById('sendBtn').classList.remove('active');
      
      // Send
      await db.ref(`messages/${currentRoomId}`).push({
        text: encrypted,
        sender: currentUser.uid,
        ts: timestamp
      });
      
      // Update metadata
      const updates = {};
      updates[`users/${currentUser.uid}/chats/${currentFriendUid}/lastMsg`] = encrypted;
      updates[`users/${currentUser.uid}/chats/${currentFriendUid}/ts`] = timestamp;
      updates[`users/${currentFriendUid}/chats/${currentUser.uid}/lastMsg`] = encrypted;
      updates[`users/${currentFriendUid}/chats/${currentUser.uid}/ts`] = timestamp;
      updates[`users/${currentFriendUid}/chats/${currentUser.uid}/unreadCount`] = firebase.database.ServerValue.increment(1);
      
      await db.ref().update(updates);
    }

    function markAsRead(friendUid) {
      db.ref(`users/${currentUser.uid}/chats/${friendUid}/unreadCount`).set(0);
    }

    function autoResize(field) {
      field.style.height = 'auto';
      field.style.height = Math.min(field.scrollHeight, 120) + 'px';
      document.getElementById('sendBtn').classList.toggle('active', field.value.trim().length > 0);
    }

    function handleEnter(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function searchFriends() {
      const query = document.getElementById('search-input').value.toLowerCase();
      const filtered = usersList.filter(u => u.name.toLowerCase().includes(query));
      renderFriendList(filtered);
    }

    auth.onAuthStateChanged(user => {
      if (!user) { window.location.href = 'login.html'; return; }
      currentUser = user;
      if (!localStorage.getItem('privateKey')) {
        generateKeyPair().then(pub => {
          if (pub) db.ref(`users/${user.uid}/profile`).update({ publicKey: JSON.stringify(pub) });
        });
      }
      loadAllFriends();
    });
  </script>
</body>
</html>
