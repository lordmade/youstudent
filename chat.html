<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BanterBox - Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --primary: #ef4444;
      --primary-dark: #dc2626;
      --bg-light: #f9f9f9;
      --bg-dark: #1f2937;
      --card-light: #ffffff;
      --card-dark: #374151;
      --text-light: #111827;
      --text-dark: #e5e7eb;
      --muted-light: #6b7280;
      --muted-dark: #9ca3af;
      --border-light: #d1d5db;
      --border-dark: #4b5563;
    }
    * {
      -webkit-user-select: none;
      user-select: none;
      box-sizing: border-box;
    }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-light);
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    body.dark {
      background: var(--bg-dark);
    }
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--card-light);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10;
      height: 56px;
    }
    header.dark {
      background: var(--card-dark);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #friend-profile-link {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
    }
    #notification {
      position: fixed;
      top: 64px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: var(--text-dark);
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 20;
      display: none;
      max-width: 90%;
      font-size: 0.875rem;
      cursor: pointer;
      animation: slideIn 0.3s ease;
    }
    #notification.dark {
      background: var(--primary-dark);
    }
    @keyframes slideIn {
      from { transform: translate(-50%, -100%); opacity: 0; }
      to { transform: translate(-50%, 0); opacity: 1; }
    }
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 72px 1rem 80px;
      background: var(--card-light);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      scroll-behavior: smooth;
    }
    #messages.dark {
      background: var(--bg-dark);
    }
    #no-messages {
      text-align: center;
      color: var(--muted-light);
      font-size: 0.875rem;
      padding: 1rem;
      display: none;
    }
    #no-messages.dark {
      color: var(--muted-dark);
    }
    .message-container {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      margin-bottom: 0.5rem;
    }
    .message-container.friend {
      align-items: flex-start;
    }
    .message {
      max-width: 80%;
      padding: 0.5rem 1rem;
      border-radius: 12px;
      font-size: 0.9375rem;
      line-height: 1.4;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      white-space: pre-wrap;
      position: relative;
      -webkit-user-select: text;
      user-select: text;
      -webkit-touch-callout: default;
      color: var(--text-light);
    }
    .message.dark {
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      color: var(--text-dark);
    }
    .message.long-press {
      user-select: none !important;
      -webkit-user-select: none !important;
      -webkit-touch-callout: none !important;
      background: rgba(0,0,0,0.05);
    }
    .message.self {
      background: #fee2e2;
      border-bottom-right-radius: 4px;
    }
    .message.friend {
      background: #e5e7eb;
      border-bottom-left-radius: 4px;
    }
    .message.self.dark {
      background: #7f1d1d;
    }
    .message.friend.dark {
      background: var(--border-dark);
    }
    .message small {
      display: block;
      font-size: 0.6875rem;
      margin-top: 0.25rem;
      text-align: right;
      color: var(--muted-light);
    }
    .message.friend small {
      text-align: left;
    }
    .message.dark small {
      color: var(--muted-dark);
    }
    .message img {
      height: 48px;
      width: 48px;
      object-fit: contain;
      margin: 0.25rem 0;
      border-radius: 4px;
    }
    .reaction {
      font-size: 0.875rem;
      margin-top: 0.25rem;
      display: flex;
      gap: 0.25rem;
    }
    .message-container.self .reaction {
      justify-content: flex-end;
    }
    .message-container.friend .reaction {
      justify-content: flex-start;
    }
    .reply-preview {
      background: #f3f4f6;
      border-left: 4px solid var(--primary);
      padding: 0.5rem 2.5rem 0.5rem 1rem;
      margin-bottom: 0.5rem;
      border-radius: 8px;
      font-size: 0.8125rem;
      color: var(--text-light);
      position: relative;
    }
    .reply-preview.dark {
      background: var(--border-dark);
      color: var(--text-dark);
    }
    .quoted-text {
      font-size: 0.75rem;
      color: var(--muted-light);
      margin-bottom: 0.25rem;
      border-left: 2px solid var(--border-light);
      padding-left: 0.5rem;
    }
    .quoted-text.dark {
      color: var(--muted-dark);
      border-left-color: var(--border-dark);
    }
    #input-area {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--card-light);
      padding: 0.75rem 1rem;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }
    #input-area.dark {
      background: var(--card-dark);
      box-shadow: 0 -2px 4px rgba(0,0,0,0.2);
    }
    #input-form {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    #message-input {
      flex: 1;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      border: 1px solid var(--border-light);
      font-size: 0.9375rem;
      line-height: 1.4;
      height: 40px;
      background: var(--card-light);
      color: var(--text-light);
    }
    #message-input.dark {
      border-color: var(--border-dark);
      background: var(--border-dark);
      color: var(--text-dark);
    }
    #message-input:focus {
      outline: 2px solid var(--primary);
      border-color: transparent;
    }
    #message-input.dark:focus {
      outline-color: var(--primary-dark);
    }
    #emoji-btn {
      background: var(--border-light);
      color: var(--muted-light);
      border-radius: 9999px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: none;
      font-size: 1.25rem;
      transition: transform 0.2s ease, background-color 0.2s ease;
    }
    #emoji-btn.dark {
      background: var(--border-dark);
      color: var(--muted-dark);
    }
    #emoji-btn:hover {
      background: #d1d5db;
      transform: scale(1.1);
    }
    #emoji-btn.dark:hover {
      background: #6b7280;
    }
    #emoji-btn:focus {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }
    #emoji-btn.dark:focus {
      outline-color: var(--primary-dark);
    }
    #send-btn {
      background: var(--primary);
      color: var(--text-dark);
      padding: 0 1rem;
      border-radius: 9999px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      height: 40px;
      font-size: 0.875rem;
      transition: background-color 0.2s ease;
    }
    #send-btn.dark {
      background: var(--primary-dark);
    }
    #send-btn:hover {
      background: var(--primary-dark);
    }
    #send-btn:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }
    #send-btn.dark:disabled {
      background: #6b7280;
    }
    .cancel-reply {
      position: absolute;
      top: 0.5rem;
      right: 0.75rem;
      color: var(--primary);
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
    }
    .cancel-reply.dark {
      color: var(--primary-dark);
    }
    .emoji-picker {
      position: absolute;
      background: var(--card-light);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 0.5rem;
      z-index: 999;
      display: none;
      user-select: none;
    }
    .emoji-picker.dark {
      background: var(--card-dark);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .emoji-picker span {
      cursor: pointer;
      padding: 0.25rem;
      font-size: 1.25rem;
      display: inline-block;
    }
    #picker-panel {
      position: absolute;
      bottom: 5rem;
      left: 1rem;
      background: var(--card-light);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      width: 280px;
      max-height: 50vh;
      overflow-y: auto;
      z-index: 1000;
      transform: translateY(10px);
      opacity: 0;
      transition: transform 0.2s ease, opacity 0.2s ease;
      display: none;
    }
    #picker-panel.open {
      transform: translateY(0);
      opacity: 1;
      display: block;
    }
    #picker-panel.dark {
      background: var(--card-dark);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .picker-tabs {
      display: flex;
      gap: 1rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border-light);
    }
    .picker-tabs.dark {
      border-bottom: 1px solid var(--border-dark);
    }
    .picker-tab {
      padding: 0.5rem 1rem;
      font-weight: 600;
      color: var(--muted-light);
      cursor: pointer;
      transition: color 0.2s ease, border-bottom 0.2s ease;
    }
    .picker-tab.active {
      color: var(--primary);
      border-bottom: 2px solid var(--primary);
    }
    .picker-tab.dark {
      color: var(--muted-dark);
    }
    .picker-tab.active.dark {
      color: var(--primary-dark);
      border-bottom-color: var(--primary-dark);
    }
    .picker-tab:hover {
      color: var(--primary);
    }
    .picker-tab.dark:hover {
      color: var(--primary-dark);
    }
    .picker-content {
      padding: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .picker-content span {
      cursor: pointer;
      padding: 0.25rem;
      font-size: 1.5rem;
    }
    .picker-content img {
      height: 48px;
      width: 48px;
      object-fit: contain;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
    }
    .close-btn {
      color: var(--primary);
      font-size: 1.25rem;
      cursor: pointer;
      padding: 0.75rem;
    }
    .close-btn.dark {
      color: var(--primary-dark);
    }
    .mic-anim {
      animation: pulse 1s infinite;
      background: var(--primary-dark) !important;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.5); }
      70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
      100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
    }
    .modal {
      background: var(--card-light);
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      max-width: 400px;
      width: 90%;
      text-align: center;
      animation: slideIn 0.3s ease;
    }
    .modal.dark {
      background: var(--card-dark);
      color: var(--text-dark);
    }
    .modal-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1.5rem;
    }
    .modal-btn {
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .modal-btn-confirm {
      background: var(--primary);
      color: var(--text-dark);
    }
    .modal-btn-confirm:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
    }
    .modal-btn-cancel {
      background: var(--border-light);
      color: var(--text-light);
    }
    .modal-btn-cancel:hover {
      background: #d1d5db;
      transform: translateY(-2px);
    }
    .modal-btn-cancel.dark {
      background: var(--border-dark);
      color: var(--text-dark);
    }
    .modal-btn-cancel.dark:hover {
      background: #6b7280;
    }
    .attribution {
      position: fixed;
      bottom: 80px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.75rem;
      color: var(--muted-light);
      padding: 0.5rem;
      z-index: 9;
    }
    .attribution.dark {
      color: var(--muted-dark);
    }
    .attribution a {
      color: var(--primary);
      text-decoration: none;
    }
    .attribution a.dark {
      color: var(--primary-dark);
    }
    @media (max-width: 640px) {
      #picker-panel {
        width: calc(100% - 2rem);
        left: 1rem;
        right: 1rem;
      }
      .message {
        max-width: 85%;
      }
    }
  </style>
</head>
<body>
  <header>
    <button onclick="location.href='index.html'" class="text-[var(--primary)] font-semibold dark:text-[var(--primary-dark)] hover:opacity-80 transition" aria-label="Back to home">←</button>
    <div id="friend-profile-link" aria-label="View friend's profile">
      <img id="friend-photo" src="https://www.gravatar.com/avatar?d=mp" class="w-10 h-10 rounded-full" alt="Friend's profile photo" />
      <div>
        <h1 id="friend-name" class="font-semibold text-lg text-[var(--text-light)] dark:text-[var(--text-dark)]">Friend</h1>
        <span id="friend-presence" class="text-sm text-[var(--muted-light)] dark:text-[var(--muted-dark)]">Offline</span>
      </div>
    </div>
  </header>

  <div id="notification" aria-live="polite"></div>

  <div id="messages">
    <div id="no-messages" class="hidden">No messages yet</div>
  </div>

  <form id="input-area" onsubmit="return false;">
    <div id="reply-box" class="reply-preview hidden">
      <span id="reply-text"></span>
      <span class="cancel-reply dark:cancel-reply" onclick="cancelReply()">×</span>
    </div>
    <div id="input-form" class="flex gap-2 items-center">
      <button id="emoji-btn" type="button" aria-label="Open emojis and stickers" aria-controls="picker-panel" aria-expanded="false">😊</button>
      <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" aria-label="Message input" />
      <button id="send-btn" type="button" aria-label="Send message or start voice input">Voice</button>
    </div>
  </form>

  <div id="emoji-picker" class="emoji-picker">
    <span>👍</span><span>😂</span><span>🔥</span><span>❤️</span><span>😢</span><span>😡</span>
  </div>

  <div id="picker-panel" class="picker-panel">
    <div class="picker-tabs">
      <button class="picker-tab active" data-tab="emojis">Emojis</button>
      <button class="picker-tab" data-tab="stickers">Stickers</button>
      <span class="close-btn" onclick="togglePickerPanel()" aria-label="Close picker">×</span>
    </div>
    <div id="emoji-content" class="picker-content">
      <span>👍</span><span>😂</span><span>🔥</span><span>❤️</span><span>😢</span><span>😡</span>
    </div>
    <div id="sticker-content" class="picker-content hidden">
      <img src="https://cdn-icons-png.flaticon.com/128/616/616430.png" alt="Cat Sticker">
      <img src="https://cdn-icons-png.flaticon.com/128/616/616498.png" alt="Dog Sticker">
      <img src="https://cdn-icons-png.flaticon.com/128/1828/1828970.png" alt="Star Sticker">
      <img src="https://cdn-icons-png.flaticon.com/128/2997/2997933.png" alt="Party Sticker">
      <img src="https://cdn-icons-png.flaticon.com/128/415/415733.png" alt="Apple Sticker">
      <img src="https://cdn-icons-png.flaticon.com/128/3201/3201495.png" alt="Rocket Sticker">
    </div>
  </div>

  <div id="delete-message-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="modal">
      <p class="text-lg font-semibold">Delete Message</p>
      <p class="mt-2 text-[var(--muted-light)] dark:text-[var(--muted-dark)]">Are you sure you want to delete this message?</p>
      <div class="modal-buttons">
        <button id="modal-confirm" class="modal-btn modal-btn-confirm">Delete</button>
        <button id="modal-cancel" class="modal-btn modal-btn-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="attribution">
    Icons by <a href="https://www.flaticon.com/authors/freepik" target="_blank">Freepik</a> from <a href="https://www.flaticon.com" target="_blank">Flaticon</a>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getDatabase, ref, onValue, push, update, get, remove, onChildAdded, query, limitToLast } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878-default-rtdb.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.appspot.com",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth();
    const db = getDatabase();

    const messagesEl = document.getElementById("messages");
    const noMessagesEl = document.getElementById("no-messages");
    const messageInput = document.getElementById("message-input");
    const sendBtn = document.getElementById("send-btn");
    const replyBox = document.getElementById("reply-box");
    const replyText = document.getElementById("reply-text");
    const emojiPicker = document.getElementById("emoji-picker");
    const friendProfileLink = document.getElementById("friend-profile-link");
    const deleteMessageModal = document.getElementById("delete-message-modal");
    const modalConfirm = document.getElementById("modal-confirm");
    const modalCancel = document.getElementById("modal-cancel");
    const notificationEl = document.getElementById("notification");
    const pickerPanel = document.getElementById("picker-panel");
    const emojiContent = document.getElementById("emoji-content");
    const stickerContent = document.getElementById("sticker-content");
    const emojiBtn = document.getElementById("emoji-btn");

    let currentUser, friendUid, chatId, friendName;
    let replyingTo = null;
    let reactingKey = null;
    let deletingKey = null;
    let theme = 'light';
    let lastMessageKey = null;

    function getParam(name) {
      return new URLSearchParams(location.search).get(name);
    }

    function formatTime(ms) {
      const d = new Date(ms);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function cancelReply() {
      replyingTo = null;
      replyBox.classList.add("hidden");
      replyText.textContent = "";
      messageInput.focus();
    }

    function showDeleteMessageModal(key) {
      deletingKey = key;
      deleteMessageModal.classList.remove("hidden");
      modalConfirm.onclick = async () => {
        try {
          await remove(ref(db, `messages/${chatId}/${key}`));
          deleteMessageModal.classList.add("hidden");
          deletingKey = null;
        } catch (error) {
          console.error("Error deleting message:", error);
          showError("Failed to delete message: " + error.message);
        }
      };
      modalCancel.onclick = () => {
        deleteMessageModal.classList.add("hidden");
        deletingKey = null;
      };
    }

    function showNotification(senderName, text) {
      if (messagesEl.scrollTop + messagesEl.clientHeight < messagesEl.scrollHeight - 50) {
        notificationEl.textContent = `${senderName}: ${text.length > 30 ? text.substring(0, 30) + '...' : text}`;
        notificationEl.classList.add(theme === 'dark' ? 'dark' : '');
        notificationEl.style.display = 'block';
        setTimeout(() => {
          notificationEl.style.display = 'none';
          notificationEl.classList.remove('dark');
        }, 3000);
        notificationEl.onclick = () => {
          notificationEl.style.display = 'none';
          messagesEl.scrollTop = messagesEl.scrollHeight;
        };
      }
    }

    function showError(message) {
      noMessagesEl.classList.remove("hidden");
      noMessagesEl.textContent = message;
      console.error(message);
      setTimeout(() => {
        noMessagesEl.classList.add("hidden");
        noMessagesEl.textContent = "No messages yet";
      }, 5000);
    }

    function togglePickerPanel() {
      console.log("Toggling picker panel");
      const isOpen = pickerPanel.classList.contains("open");
      pickerPanel.classList.toggle("open", !isOpen);
      pickerPanel.style.display = isOpen ? "none" : "block";
      emojiBtn.setAttribute("aria-expanded", !isOpen);
      if (!isOpen) {
        emojiContent.style.display = "flex";
        stickerContent.style.display = "none";
        document.querySelector(".picker-tab[data-tab='emojis']").classList.add("active");
        document.querySelector(".picker-tab[data-tab='stickers']").classList.remove("active");
      }
    }

    function renderMessages(messages) {
      console.log("Rendering messages:", messages);
      messagesEl.innerHTML = "";
      noMessagesEl.classList.add("hidden");
      if (!messages || messages.length === 0) {
        console.log("No messages to render");
        noMessagesEl.classList.remove("hidden");
        noMessagesEl.textContent = "No messages yet";
        return;
      }
      const fragment = document.createDocumentFragment();
      messages.forEach(([key, m]) => {
        console.log("Processing message:", key, m);
        const isSelf = m.sender === currentUser.uid;
        const container = document.createElement("div");
        container.className = `message-container ${isSelf ? "self" : "friend"}`;

        const div = document.createElement("div");
        div.className = `message ${isSelf ? "self" : "friend"} ${theme === 'dark' ? 'dark' : ''}`;

        let pressTimer = null;
        let startX = null;
        let longPressActive = false;

        div.addEventListener("touchstart", (e) => {
          div.classList.add("long-press");
          startX = e.touches[0].clientX;
          pressTimer = setTimeout(() => {
            longPressActive = true;
            if (isSelf) {
              showDeleteMessageModal(key);
            } else {
              showEmojiPicker(div, key);
            }
          }, 600);
        });

        div.addEventListener("touchend", (e) => {
          if (pressTimer) clearTimeout(pressTimer);
          div.classList.remove("long-press");

          if (!longPressActive) {
            const endX = e.changedTouches[0].clientX;
            const deltaX = endX - startX;
            if (deltaX > 60) {
              replyingTo = m.text;
              replyText.textContent = m.text.length > 50 ? m.text.substring(0, 50) + '...' : m.text;
              replyBox.classList.remove("hidden");
              messageInput.focus();
            } else if (deltaX < -60 && isSelf) {
              showDeleteMessageModal(key);
            }
          }
          longPressActive = false;
          startX = null;
        });

        div.addEventListener("touchmove", () => {
          if (pressTimer) clearTimeout(pressTimer);
          div.classList.remove("long-press");
          longPressActive = false;
        });

        if (m.replyTo) {
          const quote = document.createElement("div");
          quote.className = `quoted-text ${theme === 'dark' ? 'dark' : ''}`;
          quote.textContent = m.replyTo.length > 50 ? m.replyTo.substring(0, 50) + '...' : m.replyTo;
          div.appendChild(quote);
        }

        if (m.text.match(/\.(png|jpg|jpeg|gif)$/i)) {
          const img = document.createElement("img");
          img.src = m.text;
          img.alt = "Sticker";
          div.appendChild(img);
        } else {
          div.appendChild(document.createTextNode(m.text));
        }

        const time = document.createElement("small");
        time.textContent = isSelf
          ? `${formatTime(m.timestamp)} • ${m.read ? "Delivered" : "Sent"}`
          : formatTime(m.timestamp);
        div.appendChild(time);

        container.appendChild(div);

        if (m.reaction) {
          const reaction = document.createElement("div");
          reaction.className = "reaction";
          reaction.textContent = m.reaction;
          container.appendChild(reaction);
        }

        fragment.appendChild(container);
        if (!lastMessageKey || key > lastMessageKey) lastMessageKey = key;
      });
      messagesEl.appendChild(fragment);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      console.log("Messages rendered, total:", messages.length);
    }

    function showEmojiPicker(target, key) {
      const rect = target.getBoundingClientRect();
      emojiPicker.style.top = `${rect.top - 40 + window.scrollY}px`;
      emojiPicker.style.left = `${rect.left}px`;
      emojiPicker.style.display = "flex";
      reactingKey = key;
    }

    function applyTheme(themeValue) {
      console.log("Applying theme:", themeValue);
      theme = themeValue;
      document.body.classList.toggle('dark', theme === 'dark');
      document.querySelector('header').classList.toggle('dark', theme === 'dark');
      messagesEl.classList.toggle('dark', theme === 'dark');
      noMessagesEl.classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.message').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.quoted-text').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      replyBox.classList.toggle('dark', theme === 'dark');
      document.querySelector('.cancel-reply').classList.toggle('dark', theme === 'dark');
      document.querySelector('#input-area').classList.toggle('dark', theme === 'dark');
      document.querySelector('#message-input').classList.toggle('dark', theme === 'dark');
      sendBtn.classList.toggle('dark', theme === 'dark');
      emojiPicker.classList.toggle('dark', theme === 'dark');
      emojiBtn.classList.toggle('dark', theme === 'dark');
      pickerPanel.classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.picker-tabs').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.picker-tab').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.picker-tab.active').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelector('.close-btn').classList.toggle('dark', theme === 'dark');
      deleteMessageModal.classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.modal-btn-cancel').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelector('.attribution').classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.attribution a').forEach(el => el.classList.toggle('dark', theme === 'dark'));
    }

    document.addEventListener("click", (e) => {
      if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
        emojiPicker.style.display = "none";
        reactingKey = null;
      }
      if (!pickerPanel.contains(e.target) && e.target !== emojiBtn) {
        pickerPanel.classList.remove("open");
        pickerPanel.style.display = "none";
        emojiBtn.setAttribute("aria-expanded", "false");
      }
      if (!deleteMessageModal.contains(e.target) && e.target !== modalConfirm && e.target !== modalCancel) {
        deleteMessageModal.classList.add("hidden");
        deletingKey = null;
      }
    });

    emojiBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      togglePickerPanel();
    });

    async function checkBlockedStatus() {
      if (!currentUser || !friendUid) {
        console.log("checkBlockedStatus: Missing user or friendUid");
        return;
      }
      try {
        console.log("Checking blocked status:", currentUser.uid, friendUid);
        const [blockedByMe, blockedByFriend] = await Promise.all([
          get(ref(db, `users/${currentUser.uid}/blockedUsers/${friendUid}`)),
          get(ref(db, `users/${friendUid}/blockedUsers/${currentUser.uid}`))
        ]);
        if (blockedByMe.exists() || blockedByFriend.exists()) {
          console.log("User is blocked, hiding input");
          document.getElementById("input-area").style.display = "none";
          showError("Chat is blocked");
        } else {
          console.log("User not blocked, showing input");
          document.getElementById("input-area").style.display = "flex";
        }
      } catch (error) {
        console.error("Error checking blocked status:", error);
        showError("Failed to check blocked status: " + error.message);
      }
    }

    onAuthStateChanged(auth, async (user) => {
      console.log("Auth state changed, user:", user ? user.uid : null);
      if (!user) {
        console.log("No user, redirecting to login");
        showError("Please log in to view chats");
        return location.href = "login.html";
      }
      currentUser = user;
      friendUid = getParam("uid");
      if (!friendUid) {
        console.error("No friendUid in URL");
        showError("Friend UID not provided");
        return location.href = "index.html";
      }
      chatId = currentUser.uid < friendUid ? `${currentUser.uid}_${friendUid}` : `${friendUid}_${currentUser.uid}`;
      console.log("Chat ID:", chatId);

      try {
        console.log("Fetching user data...");
        const [settingsSnap, userSnap, presenceSnap, lastSeenSnap] = await Promise.all([
          get(ref(db, `users/${user.uid}/settings`)),
          get(ref(db, `users/${friendUid}`)),
          get(ref(db, `users/${friendUid}/presence`)),
          get(ref(db, `users/${friendUid}/lastSeen`))
        ]);

        theme = settingsSnap.val()?.theme || 'light';
        applyTheme(theme);

        if (!userSnap.exists()) {
          console.error("Friend not found:", friendUid);
          showError("Friend not found");
          return location.href = "index.html";
        }
        const data = userSnap.val();
        friendName = data.name || "Friend";
        console.log("Friend data:", { name: friendName, photoURL: data.photoURL });
        document.getElementById("friend-name").textContent = friendName;
        document.getElementById("friend-photo").src = data.photoURL || "https://www.gravatar.com/avatar?d=mp";

        if (presenceSnap.val() === "online") {
          document.getElementById("friend-presence").textContent = "Online";
        } else if (lastSeenSnap.val()) {
          const lastSeenDate = new Date(lastSeenSnap.val());
          document.getElementById("friend-presence").textContent = `Last seen at ${lastSeenDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        } else {
          document.getElementById("friend-presence").textContent = "Offline";
        }
      } catch (error) {
        console.error("Error loading user data:", error);
        showError("Failed to load chat: " + error.message);
        return location.href = "index.html";
      }

      friendProfileLink.onclick = () => {
        location.href = `profile.html?uid=${friendUid}`;
      };

      await checkBlockedStatus();
      onValue(ref(db, `users/${currentUser.uid}/blockedUsers/${friendUid}`), checkBlockedStatus);
      onValue(ref(db, `users/${friendUid}/blockedUsers/${currentUser.uid}`), checkBlockedStatus);

      const messagesQuery = query(ref(db, `messages/${chatId}`), limitToLast(50));
      onValue(messagesQuery, (snap) => {
        console.log("Messages snapshot:", snap.val());
        messagesEl.innerHTML = "";
        noMessagesEl.classList.add("hidden");
        if (!snap.exists()) {
          console.log("No messages for chatId:", chatId);
          noMessagesEl.classList.remove("hidden");
          noMessagesEl.textContent = "No messages yet";
          return;
        }
        const messages = Object.entries(snap.val() || {}).sort((a, b) => a[1].timestamp - b[1].timestamp);
        renderMessages(messages);
        messages.forEach(([key, m]) => {
          if (m.sender !== currentUser.uid && !m.read) {
            update(ref(db, `messages/${chatId}/${key}`), { read: true }).catch(error => {
              console.error("Error marking message as read:", error);
            });
          }
        });
      }, (error) => {
        console.error("Messages listener error:", error);
        showError(`Failed to load messages: ${error.message}`);
      });

      onChildAdded(ref(db, `messages/${chatId}`), (snap) => {
        console.log("New message:", snap.key, snap.val());
        const msg = snap.val();
        const isSelf = msg.sender === currentUser.uid;
        if (!isSelf) {
          showNotification(friendName, msg.text);
          renderMessages([[snap.key, msg]]);
        }
      }, (error) => {
        console.error("onChildAdded error:", error);
        showError("Failed to load new messages: " + error.message);
      });

      try {
        await update(ref(db, `users/${currentUser.uid}`), {
          presence: "online",
          lastSeen: Date.now()
        });
        console.log("Presence set to online");
      } catch (error) {
        console.error("Error setting presence:", error);
      }
      window.addEventListener("beforeunload", () => {
        update(ref(db, `users/${currentUser.uid}`), {
          presence: "offline",
          lastSeen: Date.now()
        }).catch(error => console.error("Error on unload:", error));
      });
    });

    function updateSendButton() {
      const hasText = messageInput.value.trim() !== "";
      sendBtn.textContent = hasText ? "Send" : "Voice";
      sendBtn.classList.remove("mic-anim");
      sendBtn.disabled = !hasText && !('webkitSpeechRecognition' in window);
    }

    messageInput.addEventListener("input", updateSendButton);
    messageInput.addEventListener("focus", updateSendButton);
    messageInput.addEventListener("blur", () => {
      if (!messageInput.value.trim()) {
        sendBtn.textContent = "Voice";
        sendBtn.classList.remove("mic-anim");
        sendBtn.disabled = !('webkitSpeechRecognition' in window);
      }
    });

    let recognition;
    let isRecording = false;
    if ('webkitSpeechRecognition' in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isRecording = true;
        sendBtn.textContent = "Listening...";
        sendBtn.classList.add("mic-anim");
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript.trim();
        messageInput.value = transcript;
        messageInput.focus();
        updateSendButton();
      };

      recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
        showError(`Speech recognition error: ${event.error}`);
        resetVoiceButton();
      };

      recognition.onend = () => {
        isRecording = false;
        if (messageInput.value.trim()) {
          sendBtn.textContent = "Send";
          sendBtn.disabled = false;
        } else {
          resetVoiceButton();
        }
        sendBtn.classList.remove("mic-anim");
      };
    } else {
      console.log("Speech recognition not supported");
      sendBtn.textContent = "Send";
      sendBtn.disabled = true;
      sendBtn.title = "Voice input not supported";
    }

    function resetVoiceButton() {
      isRecording = false;
      sendBtn.textContent = "Voice";
      sendBtn.classList.remove("mic-anim");
      sendBtn.disabled = !('webkitSpeechRecognition' in window);
    }

    sendBtn.onclick = async () => {
      if (isRecording) {
        recognition.stop();
        return;
      }

      const text = messageInput.value.trim();
      if (text) {
        const msg = {
          sender: currentUser.uid,
          text,
          timestamp: Date.now(),
          read: false
        };
        if (replyingTo) msg.replyTo = replyingTo;
        try {
          console.log("Sending message:", msg);
          await push(ref(db, `messages/${chatId}`), msg);
          messageInput.value = "";
          updateSendButton();
          cancelReply();
        } catch (error) {
          console.error("Error sending message:", error);
          showError("Failed to send message: " + error.message);
        }
      } else if (recognition) {
        recognition.start();
      } else {
        showError("Voice input not supported");
      }
    };

    document.querySelector('.cancel-reply').addEventListener('click', cancelReply);

    let isLoadingMore = false;
    messagesEl.addEventListener('scroll', async () => {
      if (messagesEl.scrollTop < 50 && !isLoadingMore && lastMessageKey) {
        isLoadingMore = true;
        try {
          console.log("Loading older messages, last key:", lastMessageKey);
          const olderMessagesQuery = query(ref(db, `messages/${chatId}`), limitToLast(50));
          const snap = await get(olderMessagesQuery);
          if (snap.exists()) {
            const messages = Object.entries(snap.val()).sort((a, b) => a[1].timestamp - b[1].timestamp);
            console.log("Older messages:", messages);
            const fragment = document.createDocumentFragment();
            messages.forEach(([key, m]) => {
              const isSelf = m.sender === currentUser.uid;
              const container = document.createElement("div");
              container.className = `message-container ${isSelf ? "self" : "friend"}`;

              const div = document.createElement("div");
              div.className = `message ${isSelf ? "self" : "friend"} ${theme === 'dark' ? 'dark' : ''}`;

              let pressTimer = null;
              let startX = null;
              let longPressActive = false;

              div.addEventListener("touchstart", (e) => {
                div.classList.add("long-press");
                startX = e.touches[0].clientX;
                pressTimer = setTimeout(() => {
                  longPressActive = true;
                  if (isSelf) {
                    showDeleteMessageModal(key);
                  } else {
                    showEmojiPicker(div, key);
                  }
                }, 600);
              });

              div.addEventListener("touchend", (e) => {
                if (pressTimer) clearTimeout(pressTimer);
                div.classList.remove("long-press");

                if (!longPressActive) {
                  const endX = e.changedTouches[0].clientX;
                  const deltaX = endX - startX;
                  if (deltaX > 60) {
                    replyingTo = m.text;
                    replyText.textContent = m.text.length > 50 ? m.text.substring(0, 50) + '...' : m.text;
                    replyBox.classList.remove("hidden");
                    messageInput.focus();
                  } else if (deltaX < -60 && isSelf) {
                    showDeleteMessageModal(key);
                  }
                }
                longPressActive = false;
                startX = null;
              });

              div.addEventListener("touchmove", () => {
                if (pressTimer) clearTimeout(pressTimer);
                div.classList.remove("long-press");
                longPressActive = false;
              });

              if (m.replyTo) {
                const quote = document.createElement("div");
                quote.className = `quoted-text ${theme === 'dark' ? 'dark' : ''}`;
                quote.textContent = m.replyTo.length > 50 ? m.replyTo.substring(0, 50) + '...' : m.replyTo;
                div.appendChild(quote);
              }

              if (m.text.match(/\.(png|jpg|jpeg|gif)$/i)) {
                const img = document.createElement("img");
                img.src = m.text;
                img.alt = "Sticker";
                div.appendChild(img);
              } else {
                div.appendChild(document.createTextNode(m.text));
              }

              const time = document.createElement("small");
              time.textContent = isSelf
                ? `${formatTime(m.timestamp)} • ${m.read ? "Delivered" : "Sent"}`
                : formatTime(m.timestamp);
              div.appendChild(time);

              container.appendChild(div);

              if (m.reaction) {
                const reaction = document.createElement("div");
                reaction.className = "reaction";
                reaction.textContent = m.reaction;
                container.appendChild(reaction);
              }

              fragment.appendChild(container);
              if (!lastMessageKey || key < lastMessageKey) lastMessageKey = key;
            });
            messagesEl.prepend(fragment);
            console.log("Older messages loaded:", messages.length);
          } else {
            console.log("No older messages");
          }
        } catch (error) {
          console.error("Error loading older messages:", error);
          showError("Failed to load older messages: " + error.message);
        } finally {
          isLoadingMore = false;
        }
      }
    });

    emojiPicker.querySelectorAll("span").forEach(span => {
      span.onclick = () => {
        if (reactingKey) {
          update(ref(db, `messages/${chatId}/${reactingKey}`), {
            reaction: span.textContent
          }).catch(error => {
            console.error("Error adding reaction:", error);
            showError("Failed to add reaction: " + error.message);
          });
          emojiPicker.style.display = "none";
          reactingKey = null;
        }
      };
    });

    document.querySelectorAll(".picker-tab").forEach(tab => {
      tab.addEventListener("click", () => {
        document.querySelectorAll(".picker-tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        emojiContent.style.display = tab.dataset.tab === "emojis" ? "flex" : "none";
        stickerContent.style.display = tab.dataset.tab === "stickers" ? "flex" : "none";
      });
    });

    [emojiContent, stickerContent].forEach(content => {
      content.querySelectorAll("span, img").forEach(item => {
        item.onclick = () => {
          messageInput.value += item.tagName === "IMG" ? item.src : item.textContent;
          messageInput.focus();
          updateSendButton();
          togglePickerPanel();
        };
      });
    });
  </script>
</body>
</html>
