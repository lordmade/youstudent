<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chaxo - Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { -webkit-user-select: none; user-select: none; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f9f9f9;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    body.dark {
      background: #1f2937;
    }
    header {
      position: fixed;
      top: 0; left: 0; right: 0;
      background: white;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 10;
      height: 56px;
    }
    header.dark {
      background: #374151;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      color: #e5e7eb;
    }
    #friend-profile-link {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      cursor: pointer;
    }
    #notification {
      position: fixed;
      top: 56px;
      left: 50%;
      transform: translateX(-50%);
      background: #ef4444;
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 20;
      display: none;
      max-width: 90%;
      font-size: 0.9rem;
      cursor: pointer;
      animation: slideIn 0.3s ease;
    }
    #notification.dark {
      background: #dc2626;
    }
    @keyframes slideIn {
      from { transform: translate(-50%, -100%); opacity: 0; }
      to { transform: translate(-50%, 0); opacity: 1; }
    }
    #encryption-notice {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      background: #f3f4f6;
      color: #4b5563;
      text-align: center;
      padding: 0.5rem;
      font-size: 0.85rem;
      z-index: 9;
      border-bottom: 1px solid #e5e7eb;
    }
    #encryption-notice.dark {
      background: #4b5563;
      color: #d1d5db;
      border-bottom: 1px solid #6b7280;
    }
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 96px 1rem 120px; /* Adjusted padding-top to account for encryption notice */
      background: white;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      scroll-behavior: smooth;
      box-sizing: border-box;
    }
    #messages.dark {
      background: #1f2937;
    }
    .message-container {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    .message-container.friend {
      align-items: flex-start;
    }
    .message {
      max-width: 75%;
      padding: 0.5rem 0.9rem;
      border-radius: 1rem;
      word-wrap: break-word;
      font-size: 0.95rem;
      line-height: 1.3;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      white-space: pre-wrap;
      position: relative;
      -webkit-user-select: text;
      user-select: text;
      -webkit-touch-callout: default;
    }
    .message.dark {
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    .message.long-press-disable-select {
      user-select: none !important;
      -webkit-user-select: none !important;
      -webkit-touch-callout: none !important;
    }
    .message.self {
      background: #fee2e2;
      color: #111827;
      border-bottom-right-radius: 6px;
    }
    .message.friend {
      background: #e5e7eb;
      color: #111827;
      border-bottom-left-radius: 6px;
    }
    .message.self.dark {
      background: #7f1d1d;
      color: #e5e7eb;
    }
    .message.friend.dark {
      background: #4b5563;
      color: #e5e7eb;
    }
    .message small {
      display: block;
      font-size: 0.7rem;
      margin-top: 4px;
      text-align: right;
    }
    .message.self small {
      color: #4b5563;
    }
    .message.friend small {
      color: #6b7280;
    }
    .message.self.dark small {
      color: #d1d5db;
    }
    .message.friend.dark small {
      color: #9ca3af;
    }
    .message img {
      height: 64px;
      width: 64px;
      object-fit: contain;
      margin: 4px 0;
    }
    .reaction {
      font-size: 1rem;
      margin-top: 4px;
      display: flex;
      gap: 4px;
    }
    .message-container.self .reaction {
      justify-content: flex-end;
    }
    .message-container.friend .reaction {
      justify-content: flex-start;
    }
    .reply-preview {
      background: #f3f4f6;
      border-left: 4px solid #ef4444;
      padding: 0.5rem 2.5rem 0.5rem 1rem;
      margin-bottom: 0.5rem;
      border-radius: 0.5rem;
      font-size: 0.85rem;
      color: #374151;
      position: relative;
    }
    .reply-preview.dark {
      background: #4b5563;
      color: #e5e7eb;
    }
    .quoted-text {
      font-size: 0.8rem;
      color: #6b7280;
      margin-bottom: 0.25rem;
      border-left: 2px solid #d1d5db;
      padding-left: 6px;
    }
    .quoted-text.dark {
      color: #9ca3af;
      border-left-color: #6b7280;
    }
    #input-area {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 0.75rem 1rem;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }
    #input-area.dark {
      background: #374151;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
    }
    #input-form {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    #message-input {
      flex: 1;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      border: 1px solid #ddd;
      font-size: 1rem;
      line-height: 1.2;
      height: 40px;
      background: white;
      color: #111827;
    }
    #message-input.dark {
      border-color: #4b5563;
      background: #4b5563;
      color: #e5e7eb;
    }
    #emoji-btn {
      background: #e5e7eb;
      color: #6b7280;
      border-radius: 9999px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #emoji-btn.dark {
      background: #4b5563;
      color: #9ca3af;
    }
    #emoji-btn:hover {
      background: #d1d5db;
    }
    #emoji-btn.dark:hover {
      background: #6b7280;
    }
    #emoji-btn svg {
      width: 24px;
      height: 24px;
    }
    #send-btn {
      background: #ef4444;
      color: white;
      padding: 0 1rem;
      border-radius: 9999px;
      font-weight: bold;
      border: none;
      cursor: pointer;
      height: 40px;
      user-select: none;
    }
    #send-btn.dark {
      background: #dc2626;
    }
    .cancel-reply {
      position: absolute;
      top: 6px;
      right: 10px;
      color: #ef4444;
      font-weight: bold;
      cursor: pointer;
    }
    .cancel-reply.dark {
      color: #dc2626;
    }
    .emoji-picker {
      position: absolute;
      background: white;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.15);
      padding: 4px 8px;
      z-index: 999;
      display: none;
      user-select: none;
    }
    .emoji-picker.dark {
      background: #374151;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .emoji-picker span {
      cursor: pointer;
      padding: 4px;
      font-size: 1.2rem;
    }
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.2);
      max-height: 50vh;
      overflow-y: auto;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      display: none;
    }
    .bottom-sheet.open {
      transform: translateY(0);
      display: block;
    }
    .bottom-sheet.dark {
      background: #374151;
    }
    .bottom-sheet-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
    }
    .bottom-sheet-header.dark {
      border-bottom: 1px solid #4b5563;
    }
    .bottom-sheet-tabs {
      display: flex;
      gap: 1rem;
    }
    .bottom-sheet-tab {
      padding: 0.5rem 1rem;
      font-weight: bold;
      color: #6b7280;
      cursor: pointer;
    }
    .bottom-sheet-tab.active {
      color: #ef4444;
      border-bottom: 2px solid #ef4444;
    }
    .bottom-sheet-tab.dark {
      color: #9ca3af;
    }
    .bottom-sheet-tab.active.dark {
      color: #dc2626;
      border-bottom-color: #dc2626;
    }
    .bottom-sheet-content {
      padding: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .bottom-sheet-content span {
      cursor: pointer;
      padding: 4px;
      font-size: 1.5rem;
    }
    .bottom-sheet-content img {
      height: 48px;
      width: 48px;
      object-fit: contain;
      cursor: pointer;
      padding: 4px;
    }
    .close-btn {
      color: #ef4444;
      font-size: 1.2rem;
      cursor: pointer;
    }
    .close-btn.dark {
      color: #dc2626;
    }
    .mic-anim {
      animation: pulse 1s infinite;
      background-color: #dc2626 !important;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 0); }
    }
    .modal {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      max-width: 400px;
      width: 90%;
      text-align: center;
      animation: slideIn 0.3s ease;
    }
    .modal.dark {
      background: #374151;
      color: #e5e7eb;
    }
    .modal-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1.5rem;
    }
    .modal-btn {
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
    .modal-btn-confirm {
      background: #ef4444;
      color: white;
    }
    .modal-btn-confirm:hover {
      background: #dc2626;
      transform: translateY(-2px);
    }
    .modal-btn-cancel {
      background: #e5e7eb;
      color: #374151;
    }
    .modal-btn-cancel:hover {
      background: #d1d5db;
      transform: translateY(-2px);
    }
    .modal-btn-cancel.dark {
      background: #4b5563;
      color: #e5e7eb;
    }
    .modal-btn-cancel.dark:hover {
      background: #6b7280;
    }
  </style>
</head>
<body>
  <header>
    <button onclick="location.href='friends.html'" class="text-red-500 font-bold dark:text-red-400">‚Üê</button>
    <div id="friend-profile-link" aria-label="Go to friend's profile">
      <img id="friend-photo" src="https://www.gravatar.com/avatar?d=mp" class="w-10 h-10 rounded-full" alt="Friend's profile photo" />
      <div>
        <h1 id="friend-name" class="font-bold text-lg dark:text-gray-100">Friend</h1>
        <span id="friend-presence" class="text-sm text-gray-500 dark:text-gray-400">Offline</span>
      </div>
    </div>
  </header>

  <div id="notification" aria-live="polite"></div>
  
  <!-- New Encryption Notice -->
  <div id="encryption-notice" class="dark:encryption-notice">
    Messages are end-to-end encrypted üîí
  </div>

  <div id="messages"></div>

  <form id="input-area" onsubmit="return false;">
    <div id="reply-box" class="reply-preview hidden">
      <span id="reply-text"></span>
      <span class="cancel-reply dark:cancel-reply" onclick="cancelReply()">√ó</span>
    </div>
    <div id="input-form" class="flex gap-0.5 items-center">
      <button id="emoji-btn" class="emoji-btn dark:emoji-btn bg-gray-200 dark:bg-gray-600 rounded-full w-10 h-10 flex items-center justify-center" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </button>
      <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-full bg-white dark:bg-gray-600 text-gray-900 dark:text-gray-100" />
      <button id="send-btn" type="button">Voice</button>
    </div>
  </form>

  <div id="emoji-picker" class="emoji-picker">
    <span>üëç</span><span>üòÇ</span><span>üî•</span><span>‚ù§Ô∏è</span><span>üò¢</span><span>üò°</span>
  </div>

  <div id="bottom-sheet" class="bottom-sheet">
    <div class="bottom-sheet-header dark:bottom-sheet-header">
      operazioni
      <div class="bottom-sheet-tabs">
        <div class="bottom-sheet-tab active" data-tab="emojis">Emojis</div>
        <div class="bottom-sheet-tab" data-tab="stickers">Stickers</div>
      </div>
      <span class="close-btn dark:close-btn" onclick="toggleBottomSheet()">√ó</span>
    </div>
    <div id="emoji-content" class="bottom-sheet-content">
      <span>üëç</span><span>üòÇ</span><span>üî•</span><span>‚ù§Ô∏è</span><span>üò¢</span><span>üò°</span>
    </div>
    <div id="sticker-content" class="bottom-sheet-content" style="display: none;">
      <img src="https://cdn-icons-png.flaticon.com/128/616/616430.png" alt="Cat Sticker" class="h-12 w-12 cursor-pointer">
      <img src="https://cdn-icons-png.flaticon.com/128/616/616498.png" alt="Dog Sticker" class="h-12 w-12 cursor-pointer">
      <img src="https://cdn-icons-png.flaticon.com/128/1828/1828970.png" alt="Star Sticker" class="h-12 w-12 cursor-pointer">
      <img src="https://cdn-icons-png.flaticon.com/128/2997/2997933.png" alt="Party Sticker" class="h-12 w-12 cursor-pointer">
      <img src="https://cdn-icons-png.flaticon.com/128/415/415733.png" alt="Apple Sticker" class="h-12 w-12 cursor-pointer">
      <img src="https://cdn-icons-png.flaticon.com/128/3201/3201495.png" alt="Rocket Sticker" class="h-12 w-12 cursor-pointer">
    </div>
  </div>

  <div id="delete-message-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="modal dark:modal">
      <p class="text-lg font-semibold dark:text-gray-100">Delete Message</p>
      <p class="mt-2 text-gray-600 dark:text-gray-300">Are you sure you want to delete this message?</p>
      <div class="modal-buttons">
        <button id="modal-confirm" class="modal-btn modal-btn-confirm">Delete</button>
        <button id="modal-cancel" class="modal-btn modal-btn-cancel dark:modal-btn-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-auth.js";
    import { getDatabase, ref, onValue, push, update, get, remove, onChildAdded, query, limitToLast, set } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.appspot.com",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth();
    const db = getDatabase();

    const messagesEl = document.getElementById("messages");
    const messageInput = document.getElementById("message-input");
    const sendBtn = document.getElementById("send-btn");
    const replyBox = document.getElementById("reply-box");
    const replyText = document.getElementById("reply-text");
    const emojiPicker = document.getElementById("emoji-picker");
    const friendProfileLink = document.getElementById("friend-profile-link");
    const deleteMessageModal = document.getElementById("delete-message-modal");
    const modalConfirm = document.getElementById("modal-confirm");
    const modalCancel = document.getElementById("modal-cancel");
    const notificationEl = document.getElementById("notification");
    const bottomSheet = document.getElementById("bottom-sheet");
    const emojiContent = document.getElementById("emoji-content");
    const stickerContent = document.getElementById("sticker-content");
    const emojiBtn = document.getElementById("emoji-btn");

    let currentUser, friendUid, chatId, friendName;
    let replyingTo = null;
    let replyingToDecrypted = null; // Store decrypted text for reply preview
    let reactingKey = null;
    let deletingKey = null;
    let theme = 'light';
    let lastMessageKey = null;

    // E2EE Functions
    async function generateAndStoreKeyPair(userId) {
      try {
        const keyPair = await crypto.subtle.generateKey(
          { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
          true,
          ["encrypt", "decrypt"]
        );
        const privateKey = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        await storePrivateKey(userId, privateKey);
        const publicKey = await crypto.subtle.exportKey("jwk", keyPair.publicKey);
        await set(ref(db, `users/${userId}/publicKey`), publicKey);
        return { privateKey, publicKey };
      } catch (error) {
        console.error("Key generation error:", error);
        showNotification("System", "Failed to generate encryption keys.");
        throw error;
      }
    }

    async function storePrivateKey(userId, privateKey) {
      const request = indexedDB.open("ChaxoKeys", 1);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore("keys", { keyPath: "userId" });
      };
      return new Promise((resolve, reject) => {
        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(["keys"], "readwrite");
          const store = transaction.objectStore("keys");
          store.put({ userId, privateKey });
          transaction.oncomplete = () => resolve();
          transaction.onerror = () => reject(transaction.error);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async function getPrivateKey(userId) {
      const request = indexedDB.open("ChaxoKeys", 1);
      return new Promise((resolve, reject) => {
        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(["keys"], "readonly");
          const store = transaction.objectStore("keys");
          const getRequest = store.get(userId);
          getRequest.onsuccess = () => resolve(getRequest.result?.privateKey);
          getRequest.onerror = () => reject(getRequest.error);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async function encryptMessage(message, recipientId) {
      try {
        const snapshot = await get(ref(db, `users/${recipientId}/publicKey`));
        if (!snapshot.exists()) throw new Error("Recipient public key not found");
        const recipientPublicKeyJwk = snapshot.val();
        const publicKey = await crypto.subtle.importKey(
          "jwk",
          recipientPublicKeyJwk,
          { name: "RSA-OAEP", hash: "SHA-256" },
          true,
          ["encrypt"]
        );
        const aesKey = await crypto.subtle.generateKey(
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt"]
        );
        const encoder = new TextEncoder();
        const encodedMessage = encoder.encode(message);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encryptedMessage = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          aesKey,
          encodedMessage
        );
        const exportedAesKey = await crypto.subtle.exportKey("raw", aesKey);
        const encryptedAesKey = await crypto.subtle.encrypt(
          { name: "RSA-OAEP" },
          publicKey,
          exportedAesKey
        );
        return {
          encryptedMessageB64: arrayBufferToBase64(encryptedMessage),
          encryptedAesKeyB64: arrayBufferToBase64(encryptedAesKey),
          ivB64: arrayBufferToBase64(iv)
        };
      } catch (error) {
        console.error("Encryption error:", error);
        throw error;
      }
    }

    async function decryptMessage(encryptedMessageB64, encryptedAesKeyB64, ivB64, userId) {
      try {
        const privateKeyJwk = await getPrivateKey(userId);
        if (!privateKeyJwk) throw new Error("Private key not found");
        const privateKey = await crypto.subtle.importKey(
          "jwk",
          privateKeyJwk,
          { name: "RSA-OAEP", hash: "SHA-256" },
          true,
          ["decrypt"]
        );
        const encryptedMessage = base64ToArrayBuffer(encryptedMessageB64);
        const encryptedAesKey = base64ToArrayBuffer(encryptedAesKeyB64);
        const iv = base64ToArrayBuffer(ivB64);
        const aesKeyRaw = await crypto.subtle.decrypt(
          { name: "RSA-OAEP" },
          privateKey,
          encryptedAesKey
        );
        const aesKey = await crypto.subtle.importKey(
          "raw",
          aesKeyRaw,
          { name: "AES-GCM" },
          true,
          ["decrypt"]
        );
        const decryptedMessage = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv },
          aesKey,
          encryptedMessage
        );
        const decoder = new TextDecoder();
        return decoder.decode(decryptedMessage);
      } catch (error) {
        console.error("Decryption error:", error);
        return "Error decrypting message.";
      }
    }

    function arrayBufferToBase64(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)));
    }

    function base64ToArrayBuffer(base64) {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function getParam(name) {
      return new URLSearchParams(location.search).get(name);
    }

    function formatTime(ms) {
      const d = new Date(ms);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function cancelReply() {
      replyingTo = null;
      replyingToDecrypted = null;
      replyBox.classList.add("hidden");
      replyText.textContent = "";
      messageInput.focus();
    }

    function showDeleteMessageModal(key) {
      deletingKey = key;
      deleteMessageModal.classList.remove("hidden");
      modalConfirm.onclick = async () => {
        try {
          await remove(ref(db, `messages/${chatId}/${key}`));
          deleteMessageModal.classList.add("hidden");
          deletingKey = null;
        } catch (error) {
          console.error("Error deleting message:", error);
          showNotification("System", "Failed to delete message.");
        }
      };
      modalCancel.onclick = () => {
        deleteMessageModal.classList.add("hidden");
        deletingKey = null;
      };
    }

    function showNotification(senderName, text) {
      if (messagesEl.scrollTop + messagesEl.clientHeight < messagesEl.scrollHeight - 50) {
        notificationEl.textContent = `${senderName}: ${text.length > 30 ? text.substring(0, 30) + '...' : text}`;
        notificationEl.classList.add(theme === 'dark' ? 'dark' : '');
        notificationEl.style.display = 'block';
        setTimeout(() => {
          notificationEl.style.display = 'none';
          notificationEl.classList.remove('dark');
        }, 3000);
        notificationEl.onclick = () => {
          notificationEl.style.display = 'none';
          messagesEl.scrollTop = messagesEl.scrollHeight;
        };
      }
    }

    function toggleBottomSheet() {
      bottomSheet.classList.toggle("open");
      if (bottomSheet.classList.contains("open")) {
        emojiContent.style.display = "flex";
        stickerContent.style.display = "none";
        document.querySelector(".bottom-sheet-tab[data-tab='emojis']").classList.add("active");
        document.querySelector(".bottom-sheet-tab[data-tab='stickers']").classList.remove("active");
      }
    }

    async function renderMessages(messages) {
      const fragment = document.createDocumentFragment();
      for (const [key, m] of messages) {
        const isSelf = m.sender === currentUser.uid;
        let displayText = m.text;
        let replyText = m.replyTo;

        if (m.encryptedMessage) {
          displayText = await decryptMessage(m.encryptedMessage, m.encryptedKey, m.iv, currentUser.uid);
          if (m.replyTo && !m.replyTo.match(/\.(png|jpg|jpeg|gif)$/i)) {
            replyText = await decryptMessage(m.replyTo, m.replyKey, m.replyIv, currentUser.uid);
          }
        }

        const container = document.createElement("div");
        container.className = `message-container ${isSelf ? "self" : "friend"}`;

        const div = document.createElement("div");
        div.className = `message ${isSelf ? "self" : "friend"} ${theme === 'dark' ? 'dark' : ''}`;

        let pressTimer = null;
        let startX = null;
        let longPressActive = false;

        div.addEventListener("touchstart", (e) => {
          div.classList.add("long-press-disable-select");
          startX = e.touches[0].clientX;
          pressTimer = setTimeout(() => {
            longPressActive = true;
            if (isSelf) {
              showDeleteMessageModal(key);
            } else {
              showEmojiPicker(div, key);
            }
          }, 600);
        });

        div.addEventListener("touchend", (e) => {
          if (pressTimer) clearTimeout(pressTimer);
          div.classList.remove("long-press-disable-select");

          if (!longPressActive) {
            const endX = e.changedTouches[0].clientX;
            const deltaX = endX - startX;
            if (deltaX > 60) {
              replyingTo = m.encryptedMessage ? m.encryptedMessage : m.text;
              replyingToDecrypted = displayText;
              replyText.textContent = displayText;
              replyBox.classList.remove("hidden");
              messageInput.focus();
            } else if (deltaX < -60 && isSelf) {
              showDeleteMessageModal(key);
            }
          }
          longPressActive = false;
          startX = null;
        });

        div.addEventListener("touchmove", () => {
          if (pressTimer) clearTimeout(pressTimer);
          div.classList.remove("long-press-disable-select");
          longPressActive = false;
        });

        if (replyText) {
          const quote = document.createElement("div");
          quote.className = `quoted-text ${theme === 'dark' ? 'dark' : ''}`;
          quote.textContent = replyText;
          div.appendChild(quote);
        }

        if (displayText.match(/\.(png|jpg|jpeg|gif)$/i)) {
          const img = document.createElement("img");
          img.src = displayText;
          img.className = "h-16 w-16 object-contain";
          img.alt = "Sticker";
          div.appendChild(img);
        } else {
          div.append(displayText);
        }

        const time = document.createElement("small");
        time.textContent = isSelf
          ? `${formatTime(m.timestamp)} ‚Ä¢ ${m.read ? "Delivered" : "Sent"}`
          : formatTime(m.timestamp);
        div.appendChild(time);

        container.appendChild(div);

        if (m.reaction) {
          const reaction = document.createElement("div");
          reaction.className = "reaction";
          reaction.textContent = m.reaction;
          container.appendChild(reaction);
        }

        fragment.appendChild(container);
        if (!lastMessageKey || key > lastMessageKey) lastMessageKey = key;
      }
      messagesEl.appendChild(fragment);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function showEmojiPicker(target, key) {
      const rect = target.getBoundingClientRect();
      emojiPicker.style.top = (rect.top - 50 + window.scrollY) + "px";
      emojiPicker.style.left = rect.left + "px";
      emojiPicker.style.display = "flex";
      reactingKey = key;
    }

    function applyTheme(themeValue) {
      theme = themeValue;
      document.body.classList.toggle('dark', theme === 'dark');
      document.querySelector('header').classList.toggle('dark', theme === 'dark');
      messagesEl.classList.toggle('dark', theme === 'dark');
      document.getElementById('encryption-notice').classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.message').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.message.friend').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.message small').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.quoted-text').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      replyBox.classList.toggle('dark', theme === 'dark');
      document.querySelector('.cancel-reply').classList.toggle('dark', theme === 'dark');
      document.querySelector('#input-area').classList.toggle('dark', theme === 'dark');
      document.querySelector('#message-input').classList.toggle('dark', theme === 'dark');
      sendBtn.classList.toggle('dark', theme === 'dark');
      emojiPicker.classList.toggle('dark', theme === 'dark');
      emojiBtn.classList.toggle('dark', theme === 'dark');
      bottomSheet.classList.toggle('dark', theme === 'dark');
      document.querySelector('.bottom-sheet-header').classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.bottom-sheet-tab').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelectorAll('.bottom-sheet-tab.active').forEach(el => el.classList.toggle('dark', theme === 'dark'));
      document.querySelector('.close-btn').classList.toggle('dark', theme === 'dark');
      deleteMessageModal.classList.toggle('dark', theme === 'dark');
      document.querySelectorAll('.modal-btn-cancel').forEach(el => el.classList.toggle('dark', theme === 'dark'));
    }

    document.addEventListener("click", (e) => {
      if (!emojiPicker.contains(e.target) && e.target !== emojiBtn && !emojiBtn.contains(e.target)) {
        emojiPicker.style.display = "none";
      }
      if (!bottomSheet.contains(e.target) && e.target !== emojiBtn && !emojiBtn.contains(e.target) && bottomSheet.classList.contains("open")) {
        bottomSheet.classList.remove("open");
      }
      if (!deleteMessageModal.contains(e.target) && e.target !== modalConfirm && e.target !== modalCancel) {
        deleteMessageModal.classList.add("hidden");
        deletingKey = null;
      }
    });

    async function checkBlockedStatus() {
      if (!currentUser || !friendUid) return;
      try {
        const [blockedByMe, blockedByFriend] = await Promise.all([
          get(ref(db, `users/${currentUser.uid}/blockedUsers/${friendUid}`)),
          get(ref(db, `users/${friendUid}/blockedUsers/${currentUser.uid}`))
        ]);
        if (blockedByMe.exists() || blockedByFriend.exists()) {
          document.getElementById("input-area").style.display = "none";
        } else {
          document.getElementById("input-area").style.display = "flex";
        }
      } catch (error) {
        console.error("Error checking blocked status:", error);
        showNotification("System", "Error checking blocked status.");
      }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) return location.href = "login.html";
      currentUser = user;
      friendUid = getParam("uid");
      if (!friendUid) {
        showNotification("System", "Friend UID not provided.");
        return location.href = "index.html";
      }
      chatId = currentUser.uid < friendUid ? `${currentUser.uid}_${friendUid}` : `${friendUid}_${currentUser.uid}`;

      // Check if user has a key pair; generate if not
      const keySnap = await get(ref(db, `users/${user.uid}/publicKey`));
      if (!keySnap.exists()) {
        await generateAndStoreKeyPair(user.uid);
      }

      try {
        const [settingsSnap, userSnap, presenceSnap, lastSeenSnap] = await Promise.all([
          get(ref(db, `users/${user.uid}/settings`)),
          get(ref(db, `users/${friendUid}`)),
          get(ref(db, `users/${friendUid}/presence`)),
          get(ref(db, `users/${friendUid}/lastSeen`))
        ]);

        theme = settingsSnap.val()?.theme || 'light';
        applyTheme(theme);

        if (!userSnap.exists()) {
          showNotification("System", "Friend not found.");
          return location.href = "index.html";
        }
        const data = userSnap.val();
        friendName = data.name || "Friend";
        document.getElementById("friend-name").textContent = friendName;
        document.getElementById("friend-photo").src = data.photoURL || "https://www.gravatar.com/avatar?d=mp";

        if (presenceSnap.val() === "online") {
          document.getElementById("friend-presence").textContent = "Online";
        } else if (lastSeenSnap.val()) {
          const lastSeenDate = new Date(lastSeenSnap.val());
          document.getElementById("friend-presence").textContent = `Last seen at ${lastSeenDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        }
      } catch (error) {
        console.error("Error loading initial data:", error);
        showNotification("System", "Failed to load chat data.");
        return location.href = "index.html";
      }

      friendProfileLink.onclick = () => {
        location.href = `profile.html?uid=${friendUid}`;
      };

      checkBlockedStatus();
      onValue(ref(db, `users/${currentUser.uid}/blockedUsers/${friendUid}`), () => checkBlockedStatus());
      onValue(ref(db, `users/${friendUid}/blockedUsers/${currentUser.uid}`), () => checkBlockedStatus());

      const messagesQuery = query(ref(db, `messages/${chatId}`), limitToLast(50));
      onValue(messagesQuery, snap => {
        messagesEl.innerHTML = "";
        if (!snap.exists()) return;
        const messages = Object.entries(snap.val()).sort((a, b) => a[1].timestamp - b[1].timestamp);
        renderMessages(messages);
        messages.forEach(([key, m]) => {
          if (m.sender !== currentUser.uid && !m.read) {
            update(ref(db, `messages/${chatId}/${key}`), { read: true }).catch(error => {
              console.error("Error marking message as read:", error);
            });
          }
        });
      });

      onChildAdded(ref(db, `messages/${chatId}`), async snap => {
        const msg = snap.val();
        const isSelf = msg.sender === currentUser.uid;
        if (!isSelf) {
          const decryptedText = msg.encryptedMessage ? await decryptMessage(msg.encryptedMessage, msg.encryptedKey, msg.iv, currentUser.uid) : msg.text;
          showNotification(friendName, decryptedText);
          renderMessages([[snap.key, msg]]);
        }
      });

      try {
        await update(ref(db, `users/${currentUser.uid}`), {
          presence: "online",
          lastSeen: Date.now()
        });
      } catch (error) {
        console.error("Error updating presence:", error);
      }
      window.addEventListener("beforeunload", () => {
        update(ref(db, `users/${currentUser.uid}`), {
          presence: "offline",
          lastSeen: Date.now()
        }).catch(error => {
          console.error("Error updating presence on unload:", error);
        });
      });
    });

    function updateSendButton() {
      const hasText = messageInput.value.trim() !== "";
      sendBtn.textContent = hasText ? "Send" : "Voice";
      sendBtn.classList.remove("mic-anim");
    }

    messageInput.addEventListener("input", updateSendButton);
    messageInput.addEventListener("focus", updateSendButton);
    messageInput.addEventListener("blur", () => {
      if (!messageInput.value.trim()) {
        sendBtn.textContent = "Voice";
        sendBtn.classList.remove("mic-anim");
      }
    });

    let recognition;
    let isRecording = false;
    if ('webkitSpeechRecognition' in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isRecording = true;
        sendBtn.textContent = "Listening...";
        sendBtn.classList.add("mic-anim");
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript.trim();
        messageInput.value = transcript;
        messageInput.focus();
        updateSendButton();
      };

      recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
        showNotification("System", `Speech recognition error: ${event.error}`);
        resetVoiceButton();
      };

      recognition.onend = () => {
        isRecording = false;
        if (messageInput.value.trim()) {
          sendBtn.textContent = "Send";
        } else {
          resetVoiceButton();
        }
        sendBtn.classList.remove("mic-anim");
      };
    } else {
      sendBtn.textContent = "Send";
      sendBtn.disabled = true;
      sendBtn.title = "Voice input not supported";
    }

    function resetVoiceButton() {
      isRecording = false;
      sendBtn.textContent = "Voice";
      sendBtn.classList.remove("mic-anim");
    }

    sendBtn.onclick = async () => {
      if (isRecording) {
        recognition.stop();
        return;
      }

      const text = messageInput.value.trim();
      if (text) {
        const msg = {
          sender: currentUser.uid,
          timestamp: Date.now(),
          read: false
        };
        try {
          if (text.match(/\.(png|jpg|jpeg|gif)$/i)) {
            msg.text = text; // Stickers are not encrypted
          } else {
            const { encryptedMessageB64, encryptedAesKeyB64, ivB64 } = await encryptMessage(text, friendUid);
            msg.encryptedMessage = encryptedMessageB64;
            msg.encryptedKey = encryptedAesKeyB64;
            msg.iv = ivB64;
            if (replyingTo) {
              if (replyingTo.match(/\.(png|jpg|jpeg|gif)$/i)) {
                msg.replyTo = replyingTo;
              } else {
                const replyData = await encryptMessage(replyingToDecrypted, friendUid);
                msg.replyTo = replyData.encryptedMessageB64;
                msg.replyKey = replyData.encryptedAesKeyB64;
                msg.replyIv = replyData.ivB64;
              }
            }
          }
          await push(ref(db, `messages/${chatId}`), msg);
          messageInput.value = "";
          updateSendButton();
          cancelReply();
        } catch (error) {
          console.error("Error sending message:", error);
          showNotification("System", "Failed to send message.");
        }
      } else if (recognition) {
        recognition.start();
      } else {
        showNotification("System", "Voice input not supported on this browser.");
      }
    };

    document.querySelector('.cancel-reply').addEventListener('click', cancelReply);

    emojiBtn.addEventListener("click", (e) => {
      e.preventDefault();
      toggleBottomSheet();
    });

    let isLoadingMore = false;
    messagesEl.addEventListener('scroll', async () => {
      if (messagesEl.scrollTop < 50 && !isLoadingMore) {
        isLoadingMore = true;
        try {
          const olderMessagesQuery = query(ref(db, `messages/${chatId}`), limitToLast(50));
          const snap = await get(olderMessagesQuery);
          if (snap.exists()) {
            const messages = Object.entries(snap.val()).sort((a, b) => a[1].timestamp - b[1].timestamp);
            const fragment = document.createDocumentFragment();
            for (const [key, m] of messages) {
              const isSelf = m.sender === currentUser.uid;
              let displayText = m.text;
              let replyText = m.replyTo;

              if (m.encryptedMessage) {
                displayText = await decryptMessage(m.encryptedMessage, m.encryptedKey, m.iv, currentUser.uid);
                if (m.replyTo && !m.replyTo.match(/\.(png|jpg|jpeg|gif)$/i)) {
                  replyText = await decryptMessage(m.replyTo, m.replyKey, m.replyIv, currentUser.uid);
                }
              }

              const container = document.createElement("div");
              container.className = `message-container ${isSelf ? "self" : "friend"}`;

              const div = document.createElement("div");
              div.className = `message ${isSelf ? "self" : "friend"} ${theme === 'dark' ? 'dark' : ''}`;

              let pressTimer = null;
              let startX = null;
              let longPressActive = false;

              div.addEventListener("touchstart", (e) => {
                div.classList.add("long-press-disable-select");
                startX = e.touches[0].clientX;
                pressTimer = setTimeout(() => {
                  longPressActive = true;
                  if (isSelf) {
                    showDeleteMessageModal(key);
                  } else {
                    showEmojiPicker(div, key);
                  }
                }, 600);
              });

              div.addEventListener("touchend", (e) => {
                if (pressTimer) clearTimeout(pressTimer);
                div.classList.remove("long-press-disable-select");

                if (!longPressActive) {
                  const endX = e.changedTouches[0].clientX;
                  const deltaX = endX - startX;
                  if (deltaX > 60) {
                    replyingTo = m.encryptedMessage ? m.encryptedMessage : m.text;
                    replyingToDecrypted = displayText;
                    replyText.textContent = displayText;
                    replyBox.classList.remove("hidden");
                    messageInput.focus();
                  } else if (deltaX < -60 && isSelf) {
                    showDeleteMessageModal(key);
                  }
                }
                longPressActive = false;
                startX = null;
              });

              div.addEventListener("touchmove", () => {
                if (pressTimer) clearTimeout(pressTimer);
                div.classList.remove("long-press-disable-select");
                longPressActive = false;
              });

              if (replyText) {
                const quote = document.createElement("div");
                quote.className = `quoted-text ${theme === 'dark' ? 'dark' : ''}`;
                quote.textContent = replyText;
                div.appendChild(quote);
              }

              if (displayText.match(/\.(png|jpg|jpeg|gif)$/i)) {
                const img = document.createElement("img");
                img.src = displayText;
                img.className = "h-16 w-16 object-contain";
                img.alt = "Sticker";
                div.appendChild(img);
              } else {
                div.append(displayText);
              }

              const time = document.createElement("small");
              time.textContent = isSelf
                ? `${formatTime(m.timestamp)} ‚Ä¢ ${m.read ? "Delivered" : "Sent"}`
                : formatTime(m.timestamp);
              div.appendChild(time);

              container.appendChild(div);

              if (m.reaction) {
                const reaction = document.createElement("div");
                reaction.className = "reaction";
                reaction.textContent = m.reaction;
                container.appendChild(reaction);
              }

              fragment.appendChild(container);
              if (!lastMessageKey || key < lastMessageKey) lastMessageKey = key;
            }
            messagesEl.prepend(fragment);
          }
        } catch (error) {
          console.error("Error loading more messages:", error);
          showNotification("System", "Error loading more messages.");
        } finally {
          isLoadingMore = false;
        }
      }
    });

    emojiPicker.querySelectorAll("span").forEach(span => {
      span.onclick = () => {
        if (reactingKey) {
          update(ref(db, `messages/${chatId}/${reactingKey}`), {
            reaction: span.textContent
          }).catch(error => {
            console.error("Error adding reaction:", error);
            showNotification("System", "Failed to add reaction.");
          });
          emojiPicker.style.display = "none";
          reactingKey = null;
        }
      };
    });

    document.querySelectorAll(".bottom-sheet-tab").forEach(tab => {
      tab.addEventListener("click", () => {
        document.querySelectorAll(".bottom-sheet-tab").forEach(t => t.classList.remove("active"));
        tab.classList.add("active");
        emojiContent.style.display = tab.dataset.tab === "emojis" ? "flex" : "none";
        stickerContent.style.display = tab.dataset.tab === "stickers" ? "flex" : "none";
      });
    });

    [emojiContent, stickerContent].forEach(content => {
      content.querySelectorAll("span, img").forEach(item => {
        item.addEventListener("click", () => {
          messageInput.value += item.tagName === "IMG" ? item.src : item.textContent;
          messageInput.focus();
          updateSendButton();
          toggleBottomSheet();
        });
      });
    });

    /*
    Firebase Security Rules (apply in Firebase Console):
    {
      "rules": {
        "users": {
          "$uid": {
            ".read": "$uid === auth.uid",
            ".write": "$uid === auth.uid",
            "publicKey": {
              ".read": "auth != null",
              ".write": "$uid === auth.uid"
            },
            "blockedUsers": {
              ".read": "$uid === auth.uid",
              ".write": "$uid === auth.uid"
            },
            "settings": {
              ".read": "$uid === auth.uid",
              ".write": "$uid === auth.uid"
            },
            "presence": {
              ".read": "auth != null",
              ".write": "$uid === auth.uid"
            },
            "lastSeen": {
              ".read": "auth != null",
              ".write": "$uid === auth.uid"
            }
          }
        },
        "messages": {
          "$chatId": {
            ".read": "auth != null && $chatId.contains(auth.uid)",
            ".write": "auth != null && $chatId.contains(auth.uid)"
          }
        }
      }
    }
    */
  </script>
</body>
</html>
