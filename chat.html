<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BanterBox - Chat</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <style>
    /* [Your existing styles remain unchanged for brevity; only key enhancements are shown] */
    .message-list {
      /* Add virtual scroll hint */
      position: relative;
      padding-bottom: 140px; /* Consistent with input height + padding */
    }
    .load-more {
      text-align: center;
      padding: 0.5rem;
      color: #6b7280;
      cursor: pointer;
    }
    .load-more.dark { color: #9ca3af; }
    .load-more:hover { color: #ef4444; }
    .typing-indicator.active { bottom: 80px; } /* Adjusted for load-more */
    /* Enhance animations */
    @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    /* Add unread marker */
    .unread-marker {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background: #ef4444;
      color: #fff;
      padding: 0.25rem 0.75rem;
      border-radius: 10px;
      font-size: 0.75rem;
      z-index: 10;
    }
    .unread-marker.dark { background: #dc2626; }
  </style>
</head>
<body>
  <header class="header dark:header">
    <!-- [Your existing header structure] -->
  </header>
  <div class="chat-container">
    <div id="search-bar" class="search-bar dark:search-bar"></div>
    <div id="message-list" class="message-list dark:message-list" aria-live="polite" aria-relevant="additions">
      <div id="load-more" class="load-more dark:load-more" style="display: none;">Load older messages</div>
    </div>
    <div id="typing-indicator" class="typing-indicator dark:typing-indicator"></div>
    <div id="input-container" class="input-container dark:input-container"></div>
    <p id="media-error" class="error-message dark:error-message"></p>
  </div>
  <!-- [Your existing modals and overlay] -->

  <div id="loading-overlay" class="loading-overlay hidden">
    <svg class="loading-spinner" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" />
    </svg>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
    import { getDatabase, ref, onValue, push, update, get, set, remove, query, limitToLast } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-database.js";
    import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBOyZ3As4GTuNvjemvPF_SpsC6m6vqtNhc",
      authDomain: "fire-b-a8878.firebaseapp.com",
      databaseURL: "https://fire-b-a8878.firebaseio.com",
      projectId: "fire-b-a8878",
      storageBucket: "fire-b-a8878.appspot.com",
      messagingSenderId: "658673187627",
      appId: "1:658673187627:web:6e4c29af661785f0afa36e"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth();
    const db = getDatabase();
    const storage = getStorage();

    // [Your existing element references]
    const loadMore = document.getElementById("load-more");

    // Generate a secure key (for demo; in production, use a server-side key)
    const ENCRYPTION_KEY = CryptoJS.lib.WordArray.random(32).toString();

    // [Your existing utility functions (encryptMessage, decryptMessage, showLoading, hideLoading, etc.)]

    // Enhanced initialization
    async function initializeChat(user, friendUid) {
      chatId = user.uid < friendUid ? `${user.uid}_${friendUid}` : `${friendUid}_${user.uid}`;
      const chatRef = ref(db, `messages/${chatId}`);
      const chatExists = (await get(chatRef)).exists();

      if (!chatExists) {
        await set(chatRef, {});
        await set(ref(db, `userChats/${user.uid}/${chatId}`), true);
        await set(ref(db, `userChats/${friendUid}/${chatId}`), true);
      }

      // Set up presence
      const userStatusRef = ref(db, `users/${user.uid}/presence`);
      const friendStatusRef = ref(db, `users/${friendUid}/presence`);
      onValue(userStatusRef, snap => {
        if (snap.val() !== 'online') set(userStatusRef, 'online');
        window.onbeforeunload = () => set(userStatusRef, { lastSeen: Date.now(), presence: 'offline' });
      });
      onValue(friendStatusRef, snap => {
        chatStatus.textContent = snap.val() === 'online' ? 'online' : timeAgo(snap.val().lastSeen);
        chatStatus.classList.toggle('online', snap.val() === 'online');
      });
    }

    // Optimized message rendering with pagination
    let lastVisible = null;
    const PAGE_SIZE = 20;

    async function loadMessages(initial = true) {
      showLoading();
      const messagesRef = ref(db, `messages/${chatId}`);
      const q = initial ? query(messagesRef, limitToLast(PAGE_SIZE)) : query(messagesRef, limitToLast(PAGE_SIZE + 1), startAfter(lastVisible));
      const snap = await get(q);
      if (!snap.exists()) {
        hideLoading();
        return;
      }
      const messages = snap.val();
      const messageIds = Object.keys(messages).sort((a, b) => messages[b].timestamp - messages[a].timestamp);
      if (!initial && messageIds.length > PAGE_SIZE) messageIds.pop(); // Exclude the last one if not initial
      lastVisible = messages[messageIds[0]];

      messageIds.forEach(mid => {
        const msg = messages[mid];
        const isSent = msg.sender === currentUser.uid;
        renderMessage(msg, isSent, friendSnap.val(), mid, chatId, currentUser.uid);
        if (!isSent && !msg.read) update(ref(db, `messages/${chatId}/${mid}`), { read: true });
      });

      loadMore.style.display = messageIds.length === PAGE_SIZE + 1 ? 'block' : 'none';
      hideLoading();
    }

    loadMore.addEventListener('click', () => loadMessages(false));

    // [Your existing event listeners with enhancements]
    sendBtn.addEventListener('click', async () => {
      const text = messageInput.value.trim();
      if (!text) return;
      showLoading();
      try {
        const encrypted = encryptMessage(text);
        const data = {
          sender: currentUser.uid,
          text: encrypted,
          timestamp: Date.now(),
          read: false,
          ...(messageInput.dataset.replyTo && { replyTo: messageInput.dataset.replyTo, replyText: messageInput.dataset.replyText })
        };
        await push(ref(db, `messages/${chatId}`), data);
        messageInput.value = '';
        sendBtn.disabled = true;
        delete messageInput.dataset.replyTo;
        delete messageInput.dataset.replyText;
        inputContainer.classList.remove('reply-active');
        delete inputContainer.dataset.reply;
      } catch (e) {
        showError("Failed to send message. Retrying...");
        setTimeout(() => sendBtn.click(), 2000); // Auto-retry
      }
      hideLoading();
    });

    // Enhanced media upload with retry
    async function uploadMedia(files = lastFiles) {
      if (!files.length) return;
      for (const file of files) {
        if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) {
          showError('Please select valid media (image or video).');
          continue;
        }
        if (file.size > 10 * 1024 * 1024) {
          showError('Media size must be less than 10MB.');
          continue;
        }
        showLoading();
        try {
          const fileToUpload = file.type.startsWith('image/') ? await compressImage(file) : file;
          const storagePath = `media/${chatId}/${Date.now()}_${CryptoJS.MD5(file.name).toString()}`;
          const fileRef = storageRef(storage, storagePath);
          await uploadBytes(fileRef, fileToUpload);
          const url = await getDownloadURL(fileRef);
          await push(ref(db, `messages/${chatId}`), {
            sender: currentUser.uid,
            [file.type.startsWith('image/') ? 'image' : 'video']: url,
            timestamp: Date.now(),
            read: false
          });
        } catch (e) {
          showError(`Failed to upload: ${e.message}`);
          lastFiles.push(file); // Retry later
        }
        hideLoading();
      }
      mediaInput.value = '';
      lastFiles = [];
    }

    mediaRetryBtn.addEventListener('click', () => uploadMedia(lastFiles));

    // Real-time unread marker
    let lastReadTime = Date.now();
    onValue(ref(db, `messages/${chatId}`), snap => {
      const messages = snap.val() || {};
      const unread = Object.values(messages).filter(m => m.timestamp > lastReadTime && m.sender !== currentUser.uid);
      if (unread.length) {
        const marker = document.createElement('div');
        marker.className = 'unread-marker dark:unread-marker';
        marker.textContent = `${unread.length} new message${unread.length > 1 ? 's' : ''}`;
        messageList.appendChild(marker);
        lastReadTime = Date.now();
      }
    });

    onAuthStateChanged(auth, async user => {
      if (!user) {
        showLoading();
        try {
          await signInAnonymously(auth);
        } catch (e) {
          showError("Failed to sign in anonymously.");
          location.href = "signup.html";
          return;
        }
        hideLoading();
        return;
      }
      currentUser = user;
      // [Your existing initialization logic with initializeChat call]
      await initializeChat(user, urlParams.get('uid'));
      await loadMessages(true);

      // [Your existing event listeners]
    });
  </script>
</body>
</html>
